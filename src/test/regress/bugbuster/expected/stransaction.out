--start_ignore
create language plpgsql;
drop table foo cascade;
ERROR:  table "foo" does not exist
drop table tenk1 cascade;
ERROR:  table "tenk1" does not exist
--end_ignore
CREATE TABLE employee(ID int,name varchar(10),salary real,start_date date,city varchar(10),region char(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO employee values (1,'jason',40420,'02/01/2007','New York');
INSERT INTO employee values (2,'Robert',14420,'01/02/2007','Vacouver');
SELECT * FROM employee;
 id |  name  | salary | start_date |   city   | region 
----+--------+--------+------------+----------+--------
  1 | jason  |  40420 | 02-01-2007 | New York | 
  2 | Robert |  14420 | 01-02-2007 | Vacouver | 
(2 rows)

BEGIN work;
INSERT INTO employee(ID,name) values (106,'Hall');
COMMIT work;
SELECT * FROM employee;
 id  |  name  | salary | start_date |   city   | region 
-----+--------+--------+------------+----------+--------
   1 | jason  |  40420 | 02-01-2007 | New York | 
   2 | Robert |  14420 | 01-02-2007 | Vacouver | 
 106 | Hall   |        |            |          | 
(3 rows)

DROP table employee;
---create table in begin and commit transaction---
BEGIN work;
CREATE TABLE test111(id integer,name text);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
COMMIT work;
BEGIN work;
DROP TABLE test111;
COMMIT work;
CREATE TABLE Manager(ID int,name varchar(10),salary real,start_date date,city varchar(10),region char(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO Manager values (1,'jason',40420,'02/01/2007','New York');
INSERT INTO Manager values (2,'Robert',14420,'01/02/2007','Vacouver');
INSERT INTO Manager values (3,'swapna',23456,'09/02/2007','Parbhani');
INSERT INTO Manager values (4,'prachi',34567,'07/03/2007','Mumbai');
SELECT * FROM Manager;
 id |  name  | salary | start_date |   city   | region 
----+--------+--------+------------+----------+--------
  1 | jason  |  40420 | 02-01-2007 | New York | 
  2 | Robert |  14420 | 01-02-2007 | Vacouver | 
  3 | swapna |  23456 | 09-02-2007 | Parbhani | 
  4 | prachi |  34567 | 07-03-2007 | Mumbai   | 
(4 rows)

BEGIN work;
UPDATE Manager SET name = NULL WHERE id=2;
COMMIT work;
SELECT * FROM Manager;
 id |  name  | salary | start_date |   city   | region 
----+--------+--------+------------+----------+--------
  1 | jason  |  40420 | 02-01-2007 | New York | 
  2 |        |  14420 | 01-02-2007 | Vacouver | 
  3 | swapna |  23456 | 09-02-2007 | Parbhani | 
  4 | prachi |  34567 | 07-03-2007 | Mumbai   | 
(4 rows)

DROP table Manager;
--- Rolling back a Transaction ---
CREATE TABLE Manager1(ID int,name varchar(10),salary real,start_date date,city varchar(10),region char(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO Manager1 values (1,'jason',40420,'02/01/2007','New York');
INSERT INTO Manager1 values (2,'Robert',14420,'01/02/2007','Vacouver');
INSERT INTO Manager1 values (3,'swapna',23456,'09/02/2007','Parbhani');
INSERT INTO Manager1 values (4,'prachi',34567,'07/03/2007','Mumbai');
INSERT INTO Manager1 values (5,'Pranita',65555,'08/04/2007','Mumbai');
INSERT INTO Manager1 values (6,'Manisha',74444,'07/02/2007','Canada');
INSERT INTO Manager1 values (7,'Anagha',49080,'09/01/2007','Nanded');
SELECT * FROM Manager1;
 id |  name   | salary | start_date |   city   | region 
----+---------+--------+------------+----------+--------
  1 | jason   |  40420 | 02-01-2007 | New York | 
  2 | Robert  |  14420 | 01-02-2007 | Vacouver | 
  3 | swapna  |  23456 | 09-02-2007 | Parbhani | 
  4 | prachi  |  34567 | 07-03-2007 | Mumbai   | 
  5 | Pranita |  65555 | 08-04-2007 | Mumbai   | 
  6 | Manisha |  74444 | 07-02-2007 | Canada   | 
  7 | Anagha  |  49080 | 09-01-2007 | Nanded   | 
(7 rows)

BEGIN ;
SELECT * FROM Manager1 where id = 1;
 id | name  | salary | start_date |   city   | region 
----+-------+--------+------------+----------+--------
  1 | jason |  40420 | 02-01-2007 | New York | 
(1 row)

UPDATE Manager1 SET name = 'Atharva' WHERE id=1;
SELECT * FROM Manager1 where id = 1;
 id |  name   | salary | start_date |   city   | region 
----+---------+--------+------------+----------+--------
  1 | Atharva |  40420 | 02-01-2007 | New York | 
(1 row)

ROLLBACK;
SELECT * FROM Manager1 WHERE id = 1;
 id | name  | salary | start_date |   city   | region 
----+-------+--------+------------+----------+--------
  1 | jason |  40420 | 02-01-2007 | New York | 
(1 row)

DROP table Manager1;
--- Rolling back a Transaction ---
CREATE TABLE Manager11(ID int,name varchar(10),salary real,start_date date,city varchar(10),region char(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO Manager11 values (1,'jason',40420,'02/01/2007','New York');
INSERT INTO Manager11 values (2,'Robert',14420,'01/02/2007','Vacouver');
INSERT INTO Manager11 values (3,'swapna',23456,'09/02/2007','Parbhani');
INSERT INTO Manager11 values (4,'prachi',34567,'07/03/2007','Mumbai');
INSERT INTO Manager11 values (5,'Pranita',65555,'08/04/2007','Mumbai');
INSERT INTO Manager11 values (6,'Manisha',74444,'07/02/2007','Canada');
INSERT INTO Manager11 values (7,'Anagha',49080,'09/01/2007','Nanded');
INSERT INTO Manager11 values (8,'Varad' ,32100,'01/12/2007','Pune');
INSERT INTO Manager11 values (9,'Vedant',43210,'10/02/2007','Aurangabad');
SELECT * FROM Manager11;
 id |  name   | salary | start_date |    city    | region 
----+---------+--------+------------+------------+--------
  8 | Varad   |  32100 | 01-12-2007 | Pune       | 
  9 | Vedant  |  43210 | 10-02-2007 | Aurangabad | 
  1 | jason   |  40420 | 02-01-2007 | New York   | 
  2 | Robert  |  14420 | 01-02-2007 | Vacouver   | 
  3 | swapna  |  23456 | 09-02-2007 | Parbhani   | 
  4 | prachi  |  34567 | 07-03-2007 | Mumbai     | 
  5 | Pranita |  65555 | 08-04-2007 | Mumbai     | 
  6 | Manisha |  74444 | 07-02-2007 | Canada     | 
  7 | Anagha  |  49080 | 09-01-2007 | Nanded     | 
(9 rows)

BEGIN ;
DELETE FROM Manager11;
SELECT * FROM Manager11;
 id | name | salary | start_date | city | region 
----+------+--------+------------+------+--------
(0 rows)

ROLLBACK ;
SELECT * FROM Manager11;
 id |  name   | salary | start_date |    city    | region 
----+---------+--------+------------+------------+--------
  1 | jason   |  40420 | 02-01-2007 | New York   | 
  2 | Robert  |  14420 | 01-02-2007 | Vacouver   | 
  3 | swapna  |  23456 | 09-02-2007 | Parbhani   | 
  4 | prachi  |  34567 | 07-03-2007 | Mumbai     | 
  5 | Pranita |  65555 | 08-04-2007 | Mumbai     | 
  6 | Manisha |  74444 | 07-02-2007 | Canada     | 
  7 | Anagha  |  49080 | 09-01-2007 | Nanded     | 
  8 | Varad   |  32100 | 01-12-2007 | Pune       | 
  9 | Vedant  |  43210 | 10-02-2007 | Aurangabad | 
(9 rows)

DROP table Manager11;
--- Rolling back a Transaction ---
CREATE TABLE Manager10(ID int,name varchar(10),salary real,start_date date,city varchar(10),region char(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO Manager10 values (1,'jason',40420,'02/01/2007','New York');
INSERT INTO Manager10 values (2,'Robert',14420,'01/02/2007','Vacouver');
INSERT INTO Manager10 values (3,'swapna',23456,'09/02/2007','Parbhani');
INSERT INTO Manager10 values (4,'prachi',34567,'07/03/2007','Mumbai');
INSERT INTO Manager10 values (5,'Pranita',65555,'08/04/2007','Mumbai');
INSERT INTO Manager10 values (6,'Manisha',74444,'07/02/2007','Canada');
INSERT INTO Manager10 values (7,'Anagha',49080,'09/01/2007','Nanded');
INSERT INTO Manager10 values (8,'Varad' ,32100,'01/12/2007','Pune');
INSERT INTO Manager10 values (9,'Vedant',43210,'10/02/2007','Aurangabad');
SELECT * FROM Manager10;
 id |  name   | salary | start_date |    city    | region 
----+---------+--------+------------+------------+--------
  8 | Varad   |  32100 | 01-12-2007 | Pune       | 
  9 | Vedant  |  43210 | 10-02-2007 | Aurangabad | 
  1 | jason   |  40420 | 02-01-2007 | New York   | 
  2 | Robert  |  14420 | 01-02-2007 | Vacouver   | 
  3 | swapna  |  23456 | 09-02-2007 | Parbhani   | 
  4 | prachi  |  34567 | 07-03-2007 | Mumbai     | 
  5 | Pranita |  65555 | 08-04-2007 | Mumbai     | 
  6 | Manisha |  74444 | 07-02-2007 | Canada     | 
  7 | Anagha  |  49080 | 09-01-2007 | Nanded     | 
(9 rows)

BEGIN ;
UPDATE Manager10 SET salary = salary - 100 WHERE name = 'Varad';
SAVEPOINT my_savepoint;
UPDATE Manager10 SET salary = salary + 100 WHERE name = 'Vedant';
ROLLBACK TO my_savepoint;
UPDATE Manager10 SET salary = salary + 100 WHERE name = 'Anagha';
COMMIT;
SELECT * FROM Manager10;
 id |  name   | salary | start_date |    city    | region 
----+---------+--------+------------+------------+--------
  9 | Vedant  |  43210 | 10-02-2007 | Aurangabad | 
  8 | Varad   |  32000 | 01-12-2007 | Pune       | 
  1 | jason   |  40420 | 02-01-2007 | New York   | 
  2 | Robert  |  14420 | 01-02-2007 | Vacouver   | 
  3 | swapna  |  23456 | 09-02-2007 | Parbhani   | 
  4 | prachi  |  34567 | 07-03-2007 | Mumbai     | 
  5 | Pranita |  65555 | 08-04-2007 | Mumbai     | 
  6 | Manisha |  74444 | 07-02-2007 | Canada     | 
  7 | Anagha  |  49180 | 09-01-2007 | Nanded     | 
(9 rows)

DROP table Manager10;
CREATE TABLE "book" ( id integer NOT NULL,title text NOT NULL,author_id integer,subject_id integer,constraint "book_id_pkey" Primary Key ("id"));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "book_pkey" for table "book"
INSERT INTO book values (7808, 'java',4156,9);
INSERT INTO book values (4513, 'javascript',1866,15);
INSERT INTO book values (7809, 'python',4956,9);
INSERT INTO book values (4514, 'C',19866,1);
INSERT INTO book values (7810, 'C++',4336,5);
INSERT INTO book values (4515, 'Perl cookbook',189066,8);
INSERT INTO book values (7811, 'POstgreSql',41156,2);
INSERT INTO book values (4516, 'Oracle',1866,6);
SELECT * FROM book;
  id  |     title     | author_id | subject_id 
------+---------------+-----------+------------
 4513 | javascript    |      1866 |         15
 7809 | python        |      4956 |          9
 7811 | POstgreSql    |     41156 |          2
 7808 | java          |      4156 |          9
 4514 | C             |     19866 |          1
 7810 | C++           |      4336 |          5
 4515 | Perl cookbook |    189066 |          8
 4516 | Oracle        |      1866 |          6
(8 rows)

BEGIN work;
DELETE FROM book;
ABORT work;
SELECT * FROM book;
  id  |     title     | author_id | subject_id 
------+---------------+-----------+------------
 4513 | javascript    |      1866 |         15
 7809 | python        |      4956 |          9
 7811 | POstgreSql    |     41156 |          2
 7808 | java          |      4156 |          9
 4514 | C             |     19866 |          1
 7810 | C++           |      4336 |          5
 4515 | Perl cookbook |    189066 |          8
 4516 | Oracle        |      1866 |          6
(8 rows)

DROP TABLE book;
BEGIN;
CREATE TABLE Atable (a integer);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO Atable VALUES (10);
SHOW TRANSACTION ISOLATION LEVEL;
 transaction_isolation 
-----------------------
 read committed
(1 row)

DROP TABLE Atable;
COMMIT;
CREATE TABLE Manager(ID int,name varchar(10),salary real,start_date date,city varchar(10),region char(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO Manager values (1,'jason',40420,'02/01/2007','New York');
INSERT INTO Manager values (2,'Robert',14420,'01/02/2007','Vacouver');
INSERT INTO Manager values (3,'swapna',23456,'09/02/2007','Parbhani');
INSERT INTO Manager values (4,'prachi',34567,'07/03/2007','Mumbai');
SELECT * FROM Manager;
 id |  name  | salary | start_date |   city   | region 
----+--------+--------+------------+----------+--------
  1 | jason  |  40420 | 02-01-2007 | New York | 
  2 | Robert |  14420 | 01-02-2007 | Vacouver | 
  3 | swapna |  23456 | 09-02-2007 | Parbhani | 
  4 | prachi |  34567 | 07-03-2007 | Mumbai   | 
(4 rows)

BEGIN work;
SET TRANSACTION ISOLATION LEVEL  SERIALIZABLE;
SHOW TRANSACTION ISOLATION LEVEL;
 transaction_isolation 
-----------------------
 serializable
(1 row)

UPDATE Manager SET name = NULL WHERE id=2;
COMMIT work;
SHOW TRANSACTION ISOLATION LEVEL;
 transaction_isolation 
-----------------------
 read committed
(1 row)

SELECT * FROM Manager;
 id |  name  | salary | start_date |   city   | region 
----+--------+--------+------------+----------+--------
  1 | jason  |  40420 | 02-01-2007 | New York | 
  2 |        |  14420 | 01-02-2007 | Vacouver | 
  3 | swapna |  23456 | 09-02-2007 | Parbhani | 
  4 | prachi |  34567 | 07-03-2007 | Mumbai   | 
(4 rows)

DROP table Manager;
CREATE TABLE Manager(ID int,name varchar(10),salary real,start_date date,city varchar(10),region char(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO Manager values (1,'jason',40420,'02/01/2007','New York');
INSERT INTO Manager values (2,'Robert',14420,'01/02/2007','Vacouver');
INSERT INTO Manager values (3,'swapna',23456,'09/02/2007','Parbhani');
INSERT INTO Manager values (4,'prachi',34567,'07/03/2007','Mumbai');
SELECT * FROM Manager;
 id |  name  | salary | start_date |   city   | region 
----+--------+--------+------------+----------+--------
  1 | jason  |  40420 | 02-01-2007 | New York | 
  2 | Robert |  14420 | 01-02-2007 | Vacouver | 
  3 | swapna |  23456 | 09-02-2007 | Parbhani | 
  4 | prachi |  34567 | 07-03-2007 | Mumbai   | 
(4 rows)

BEGIN work;
SET SESSION CHARACTERISTICS AS  TRANSACTION ISOLATION LEVEL  SERIALIZABLE;
SHOW TRANSACTION ISOLATION LEVEL;
 transaction_isolation 
-----------------------
 read committed
(1 row)

UPDATE Manager SET name = NULL WHERE id=2;
COMMIT work;
SHOW TRANSACTION ISOLATION LEVEL;
 transaction_isolation 
-----------------------
 serializable
(1 row)

SELECT * FROM Manager;
 id |  name  | salary | start_date |   city   | region 
----+--------+--------+------------+----------+--------
  3 | swapna |  23456 | 09-02-2007 | Parbhani | 
  4 | prachi |  34567 | 07-03-2007 | Mumbai   | 
  1 | jason  |  40420 | 02-01-2007 | New York | 
  2 |        |  14420 | 01-02-2007 | Vacouver | 
(4 rows)

DROP table Manager;
CREATE TABLE Manager(ID int,name varchar(10),salary real,start_date date,city varchar(10),region char(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO Manager values (1,'jason',40420,'02/01/2007','New York');
INSERT INTO Manager values (2,'Robert',14420,'01/02/2007','Vacouver');
INSERT INTO Manager values (3,'swapna',23456,'09/02/2007','Parbhani');
INSERT INTO Manager values (4,'prachi',34567,'07/03/2007','Mumbai');
SELECT * FROM Manager;
 id |  name  | salary | start_date |   city   | region 
----+--------+--------+------------+----------+--------
  3 | swapna |  23456 | 09-02-2007 | Parbhani | 
  4 | prachi |  34567 | 07-03-2007 | Mumbai   | 
  1 | jason  |  40420 | 02-01-2007 | New York | 
  2 | Robert |  14420 | 01-02-2007 | Vacouver | 
(4 rows)

BEGIN work;
SHOW TRANSACTION ISOLATION LEVEL;
 transaction_isolation 
-----------------------
 serializable
(1 row)

SET CONSTRAINTS ALL IMMEDIATE;
UPDATE Manager SET name = NULL WHERE id=2;
COMMIT work;
SHOW TRANSACTION ISOLATION LEVEL;
 transaction_isolation 
-----------------------
 serializable
(1 row)

SELECT * FROM Manager;
 id |  name  | salary | start_date |   city   | region 
----+--------+--------+------------+----------+--------
  3 | swapna |  23456 | 09-02-2007 | Parbhani | 
  4 | prachi |  34567 | 07-03-2007 | Mumbai   | 
  1 | jason  |  40420 | 02-01-2007 | New York | 
  2 |        |  14420 | 01-02-2007 | Vacouver | 
(4 rows)

DROP table Manager;
CREATE TABLE employee(ID int,name varchar(10),salary real,start_date date,city varchar(10),region char(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO employee values (1,'jason',40420,'02/01/2007','New York');
INSERT INTO employee values (2,'Robert',14420,'01/02/2007','Vacouver');
SELECT * FROM employee;
 id |  name  | salary | start_date |   city   | region 
----+--------+--------+------------+----------+--------
  1 | jason  |  40420 | 02-01-2007 | New York | 
  2 | Robert |  14420 | 01-02-2007 | Vacouver | 
(2 rows)

START TRANSACTION ;
INSERT INTO employee(ID,name) values (106,'Hall');
COMMIT work;
SELECT * FROM employee;
 id  |  name  | salary | start_date |   city   | region 
-----+--------+--------+------------+----------+--------
   1 | jason  |  40420 | 02-01-2007 | New York | 
   2 | Robert |  14420 | 01-02-2007 | Vacouver | 
 106 | Hall   |        |            |          | 
(3 rows)

DROP table employee;
CREATE TABLE employee(ID int,name varchar(10),salary real,start_date date,city varchar(10),region char(1));
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'id' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO employee values (1,'jason',40420,'02/01/2007','New York');
INSERT INTO employee values (2,'Robert',14420,'01/02/2007','Vacouver');
SELECT * FROM employee;
 id |  name  | salary | start_date |   city   | region 
----+--------+--------+------------+----------+--------
  1 | jason  |  40420 | 02-01-2007 | New York | 
  2 | Robert |  14420 | 01-02-2007 | Vacouver | 
(2 rows)

START TRANSACTION SERIALIZABLE;
ERROR:  syntax error at or near "SERIALIZABLE"
LINE 1: START TRANSACTION SERIALIZABLE;
                          ^
INSERT INTO employee(ID,name) values (106,'Hall');
COMMIT work;
WARNING:  there is no transaction in progress
SELECT * FROM employee;
 id  |  name  | salary | start_date |   city   | region 
-----+--------+--------+------------+----------+--------
   1 | jason  |  40420 | 02-01-2007 | New York | 
   2 | Robert |  14420 | 01-02-2007 | Vacouver | 
 106 | Hall   |        |            |          | 
(3 rows)

DROP table employee;
create table tabcd (c1 text) distributed randomly;
insert into tabcd values ('a'), ('b'), ('c'), ('d');
create table t1234 (c1 integer) distributed randomly;
insert into t1234 values (1),(2),(3),(4);
create table tabcd_orig as select * from tabcd distributed randomly;
create table t1234_orig as select * from t1234 distributed randomly;
DROP FUNCTION IF EXISTS transaction_test_cursor_nit();
NOTICE:  function transaction_test_cursor_nit() does not exist, skipping
CREATE FUNCTION transaction_test_cursor_nit() RETURNS void AS '
DECLARE
ref_abcd refcursor;
ref_1234_1 refcursor;
ref_1234_2 refcursor;
abcd_var varchar;
t_1234_var_1 int;
t1234_var_2 int;
i int;
j int;
arr_1234 int [4];
arr_abcd varchar [4];
BEGIN
arr_1234[1]:=1;arr_1234[2]:=2;arr_1234[3]:=3;arr_1234[4]:=4;
open ref_1234_1 FOR SELECT c1 FROM t1234 order by 1;
BEGIN
j:=1;
open ref_abcd FOR SELECT c1 FROM tabcd order by 1;
fetch ref_abcd into abcd_var;
while abcd_var is not null loop
arr_abcd[j]:=abcd_var;
BEGIN
open ref_1234_2 FOR SELECT c1 FROM t1234 order by 1;
fetch ref_1234_2 into t1234_var_2;
i:=1;
while t1234_var_2 is not null loop
update tabcd set c1=c1||t1234_var_2 where c1=arr_abcd[j];
arr_abcd[j]:=arr_abcd[j]||t1234_var_2;
arr_1234[i]:=arr_1234[i]+10;
i:=i+1;
fetch ref_1234_2 into t1234_var_2;
end loop;
close ref_1234_2;
END;
fetch ref_abcd into abcd_var;
j:=j+1;
end loop;
close ref_abcd;
fetch ref_1234_1 into t_1234_var_1;
while t_1234_var_1 is not null loop
update t1234 set c1=arr_1234[t_1234_var_1] where c1=t_1234_var_1;
fetch ref_1234_1 into t_1234_var_1;
end loop;
END;
close ref_1234_1;
END;
' LANGUAGE plpgsql MODIFIES SQL DATA;
BEGIN;
TRUNCATE tabcd;
TRUNCATE t1234;
INSERT INTO tabcd SELECT * from tabcd_orig;
INSERT INTO t1234 SELECT * from t1234_orig;
SELECT transaction_test_cursor_nit();
 transaction_test_cursor_nit 
-----------------------------
 
(1 row)

SELECT * from tabcd order by 1;
  c1   
-------
 a1234
 b1234
 c1234
 d1234
(4 rows)

SELECT * from t1234 order by 1;
 c1 
----
 41
 42
 43
 44
(4 rows)

SELECT transaction_test_cursor_nit();
 transaction_test_cursor_nit 
-----------------------------
 
(1 row)

ABORT;
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
TRUNCATE tabcd;
TRUNCATE t1234;
INSERT INTO tabcd SELECT * from tabcd_orig;
INSERT INTO t1234 SELECT * from t1234_orig;
SELECT transaction_test_cursor_nit();
 transaction_test_cursor_nit 
-----------------------------
 
(1 row)

SELECT * from tabcd order by 1;
  c1   
-------
 a1234
 b1234
 c1234
 d1234
(4 rows)

SELECT * from t1234 order by 1;
 c1 
----
 41
 42
 43
 44
(4 rows)

SELECT transaction_test_cursor_nit();
 transaction_test_cursor_nit 
-----------------------------
 
(1 row)

ABORT;
DROP TABLE tabcd;
DROP TABLE t1234;
DROP TABLE tabcd_orig;
DROP TABLE t1234_orig;
CREATE SCHEMA prerds;
CREATE OR REPLACE FUNCTION fin_hie_acc_grp1()  returns integer as $$
declare 
c integer :=99;

begin
delete from  prerds.ramana_fin_setleaf_bt ;
Truncate Table  prerds.FINANCE_HIE_ACC_GRP ;
--LEVEL 1
insert into prerds.ramana_fin_hir  
select SUBSETNAME, SETNAME from  stgdb.stg_setnode where
SETCLASS = '0109' and SUBCLASS = 'PCOA' and setname = 'ACC_GRP';
 
Insert into prerds.FINANCE_HIE_ACC_GRP  select * from prerds.ramana_fin_hir;
 

Loop
--NEXT LEVEL

insert into prerds.ramana_fin_hir1  
select   distinct  r.subsetname, r.Setname   
from  stgdb.stg_setnode r,  prerds.ramana_fin_hir  rr
where 
r.SETCLASS = '0109'
and r.SUBCLASS = 'PCOA'
and r.SETNAME= rr.lv1 ;

Insert into prerds.FINANCE_HIE_ACC_GRP  select * from prerds.ramana_fin_hir1 ;


Insert into prerds.FINANCE_HIE_ACC_GRP1 
select   distinct  r.valfrom, r.Setname  
from  stgdb.stg_setleaf r,  prerds.ramana_fin_hir  rr
where 
r.SETCLASS = '0109'
and r.SUBCLASS = 'PCOA' and r.valoption =  'EQ'
and r.SETNAME= rr.lv1 and r.Setname in 
(select r.lv1 from prerds.ramana_fin_hir r left outer join 
prerds.ramana_fin_hir1 rr on r.lv1 = rr.lv2 where rr.lv1 is null);


Insert into prerds.ramana_fin_setleaf_bt 
select   distinct  r.Setname, r.valoption, r.valfrom, r.valto 
from  stgdb.stg_setleaf r,  prerds.ramana_fin_hir  rr
where 
r.SETCLASS = '0109'
and r.SUBCLASS = 'PCOA' and r.valoption =  'BT'
and r.SETNAME= rr.lv1 and r.Setname in 
(select r.lv1 from prerds.ramana_fin_hir r left outer join 
prerds.ramana_fin_hir1 rr on r.lv1 = rr.lv2 where rr.lv1 is null);

Exit when (select count(*) from prerds.ramana_fin_hir) = (select count(r.lv1) from prerds.ramana_fin_hir r left outer join 
prerds.ramana_fin_hir1 rr on r.lv1 = rr.lv2 where rr.lv1 is null);


delete from  prerds.ramana_fin_hir;


--NEXT2
insert into prerds.ramana_fin_hir  
select   distinct  r.subsetname,  r.Setname   
from  stgdb.stg_setnode r,  prerds.ramana_fin_hir1  rr
where 
r.SETCLASS = '0109'
and r.SUBCLASS = 'PCOA'
and r.SETNAME= rr.lv1 ;

Insert into prerds.FINANCE_HIE_ACC_GRP  select * from prerds.ramana_fin_hir ;
 
 
Insert into prerds.FINANCE_HIE_ACC_GRP1 
select   distinct  r.valfrom, r.Setname 
from  stgdb.stg_setleaf r,  prerds.ramana_fin_hir1  rr
where 
r.SETCLASS = '0109'
and r.SUBCLASS = 'PCOA' and r.valoption =  'EQ'
and r.SETNAME= rr.lv1 and r.Setname in 
(select r.lv1 from prerds.ramana_fin_hir1 r left outer join 
prerds.ramana_fin_hir rr on r.lv1 = rr.lv2 where rr.lv1 is null);


Insert into prerds.ramana_fin_setleaf_bt 
select   distinct  r.Setname, r.valoption, r.valfrom, r.valto 

from  stgdb.stg_setleaf r,  prerds.ramana_fin_hir1  rr
where 
r.SETCLASS = '0109'
and r.SUBCLASS = 'PCOA' and r.valoption =  'BT'
and r.SETNAME= rr.lv1 and r.Setname in 
(select r.lv1 from prerds.ramana_fin_hir1 r left outer join 
prerds.ramana_fin_hir rr on r.lv1 = rr.lv2 where rr.lv1 is null);


Exit when (select count(*) from prerds.ramana_fin_hir1) = (select count(r.lv1) from prerds.ramana_fin_hir1 r left outer join 
prerds.ramana_fin_hir rr on r.lv1 = rr.lv2 where rr.lv1 is null);



delete from  prerds.ramana_fin_hir1 ;

End Loop;

Insert into prerds.FINANCE_HIE_ACC_GRP1  
Select   KSTAR, setname from stgdb.stg_CSKU r, prerds.ramana_fin_setleaf_bt rr where r.ktopl = 'PCOA' and 
 r.KSTAR BETWEEN rr.valfrom and rr.valto;

delete from  prerds.ramana_fin_hir1 ;
delete from  prerds.ramana_fin_hir ;



/*------------------------------------CHAGING THE ORDER--------------------------------------*/
/*GRANULAR LEVEL*/
delete from prerds.FINANCE_HIE_ACC_GRP_FINAL ;

Insert into prerds.FINANCE_HIE_ACC_GRP_FINAL select * from prerds.FINANCE_HIE_ACC_GRP1;

/*NEXT LEVELS IN LOOP*/
Loop
delete from prerds.FINANCE_HIE_ACC_GRP_TEMP;

Insert into  prerds.FINANCE_HIE_ACC_GRP_TEMP select a.lv1,b.lv2 from prerds.FINANCE_HIE_ACC_GRP1 a, 
prerds.FINANCE_HIE_ACC_GRP  b where a.lv2 = b.lv1;

GET DIAGNOSTICS c = ROW_COUNT;
exit when c = 0;
Insert into prerds.FINANCE_HIE_ACC_GRP_FINAL select * from prerds.FINANCE_HIE_ACC_GRP_TEMP;

delete from prerds.FINANCE_HIE_ACC_GRP1  ;
Insert into prerds.FINANCE_HIE_ACC_GRP1  select * from prerds.FINANCE_HIE_ACC_GRP_TEMP;
end loop;


delete from prerds.fin_hie__desc_temp ;
insert into prerds.fin_hie__desc_temp 
 select   a.lv1,a.lv2, b.hie_desc  from prerds.FINANCE_HIE_ACC_GRP_FINAL a left outer join prerds.ramana_fin_hie_desc b 
 on a.lv2=hie_lvl ;

delete from prerds.FINANCE_HIE_ACC_GRP_FINAL;
insert into prerds.FINANCE_HIE_ACC_GRP_FINAL select * from prerds.fin_hie__desc_temp ;

Return (select count(*) from prerds.FINANCE_HIE_ACC_GRP_FINAL )  ;
end; 

$$ language plpgsql MODIFIES SQL DATA;
CREATE TABLE prerds.ramana_fin_setleaf_bt
(
  setname character varying(24),
  valoption character varying(2),
  valfrom character varying(24),
  valto character varying(24)
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'setname' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE prerds.finance_hie_acc_grp
(
  lv1 character varying,
  lv2 character varying
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'lv1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE prerds.finance_hie_acc_grp_temp
(
  lv1 character varying,
  lv2 character varying
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'lv1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE prerds.ramana_fin_hir
(
  lv1 character varying,
  lv2 character varying
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'lv1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE prerds.ramana_fin_hir1
(
  lv1 character varying,
  lv2 character varying
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'lv1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE prerds.finance_hie_acc_grp1
(
  lv1 character varying,
  lv2 character varying
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'lv1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE prerds.finance_hie_acc_grp_final
(
  lv1 character varying,
  lv2 character varying,
  description character varying
);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'lv1' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into prerds.finance_hie_acc_grp1 values ('Test','Test');
insert into prerds.finance_hie_acc_grp1 values ('Test','Test2');
insert into prerds.finance_hie_acc_grp1 values ('Test','Test2');
insert into prerds.finance_hie_acc_grp1 values ('Test','Test3');
insert into prerds.finance_hie_acc_grp1 values ('Test','Test4');
insert into prerds.finance_hie_acc_grp values ('Test','Test2');
insert into prerds.finance_hie_acc_grp values ('Test','Test2');
insert into prerds.finance_hie_acc_grp values ('Test','Test2');
insert into prerds.finance_hie_acc_grp values ('Test','Test2');
insert into prerds.finance_hie_acc_grp values ('Test','Test2');
INSERT INTO prerds.FINANCE_HIE_ACC_GRP_TEMP select a.lv1,b.lv2 from prerds.FINANCE_HIE_ACC_GRP1 a, prerds.FINANCE_HIE_ACC_GRP b where a.lv2 = b.lv1;
drop schema prerds cascade;
NOTICE:  drop cascades to table prerds.finance_hie_acc_grp_final
NOTICE:  drop cascades to table prerds.finance_hie_acc_grp1
NOTICE:  drop cascades to table prerds.ramana_fin_hir1
NOTICE:  drop cascades to table prerds.ramana_fin_hir
NOTICE:  drop cascades to table prerds.finance_hie_acc_grp_temp
NOTICE:  drop cascades to table prerds.finance_hie_acc_grp
NOTICE:  drop cascades to table prerds.ramana_fin_setleaf_bt
drop function  fin_hie_acc_grp1();
CREATE TABLE aggtest_table (a int, b float);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO aggtest_table (a, b) values (777, 777.777);
BEGIN;
SELECT * INTO TABLE xacttest_table FROM aggtest_table;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO xacttest_table (a, b) VALUES (777, 777.777);
END;
SELECT a FROM xacttest_table WHERE a > 100;
  a  
-----
 777
 777
(2 rows)

BEGIN;
CREATE TABLE disappear (a int4);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
TRUNCATE aggtest_table;
SELECT * FROM aggtest_table;
 a | b 
---+---
(0 rows)

ABORT;
SELECT oid FROM pg_class WHERE relname = 'disappear';
 oid 
-----
(0 rows)

SELECT * FROM aggtest_table;
  a  |    b    
-----+---------
 777 | 777.777
(1 row)

DROP TABLE aggtest_table;
DROP TABLE xacttest_table;
DROP TABLE disappear;
ERROR:  table "disappear" does not exist
CREATE TABLE writetest (a int) distributed randomly;
INSERT INTO writetest values (2);
CREATE TEMPORARY TABLE temptest (a int) distributed randomly;
INSERT INTO temptest values (12);
SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY;
DROP TABLE writetest; 
ERROR:  transaction is read-only
INSERT INTO writetest VALUES (1); 
ERROR:  transaction is read-only
SELECT * FROM writetest; 
 a 
---
 2
(1 row)

TRUNCATE temptest; 
ERROR:  transaction is read-only
UPDATE temptest SET a = 0 FROM writetest WHERE temptest.a = 1 AND writetest.a = temptest.a; 
PREPARE test AS UPDATE writetest SET a = 0; 
EXECUTE test; 
ERROR:  transaction is read-only
SELECT * FROM writetest, temptest; 
 a | a  
---+----
 2 | 12
(1 row)

CREATE TABLE test AS SELECT * FROM writetest; 
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  transaction is read-only
START TRANSACTION READ WRITE;
DROP TABLE writetest; 
COMMIT;
DROP TABLE temptest;
SET SESSION CHARACTERISTICS AS TRANSACTION READ WRITE;
CREATE TABLE foobar_table (a int) distributed randomly;
BEGIN;
CREATE TABLE foo_table (a int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
SAVEPOINT one;
DROP TABLE foo_table;
CREATE TABLE bar_table (a int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ROLLBACK TO SAVEPOINT one;
RELEASE SAVEPOINT one;
SAVEPOINT two;
CREATE TABLE baz_table (a int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
RELEASE SAVEPOINT two;
drop TABLE foobar_table;
CREATE TABLE barbaz_table (a int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
COMMIT;
SELECT * FROM foo_table;		
 a 
---
(0 rows)

SELECT * FROM bar_table;		
ERROR:  relation "bar_table" does not exist
LINE 1: SELECT * FROM bar_table;
                      ^
SELECT * FROM barbaz_table;	
 a 
---
(0 rows)

SELECT * FROM baz_table;		
 a 
---
(0 rows)

BEGIN;
INSERT INTO foo_table VALUES (1);
SAVEPOINT one;
INSERT into bar_table VALUES (1);
ERROR:  relation "bar_table" does not exist
ROLLBACK TO one;
RELEASE SAVEPOINT one;
SAVEPOINT two;
INSERT into barbaz_table VALUES (1);
RELEASE two;
SAVEPOINT three;
SAVEPOINT four;
INSERT INTO foo_table VALUES (2);
RELEASE SAVEPOINT four;
ROLLBACK TO SAVEPOINT three;
RELEASE SAVEPOINT three;
INSERT INTO foo_table VALUES (3);
COMMIT;
SELECT * FROM foo_table;		
 a 
---
 3
 1
(2 rows)

SELECT * FROM barbaz_table;	
 a 
---
 1
(1 row)

DROP TABLE foo_table;
DROP TABLE barbaz_table;
DROP TABLE bar_table;
ERROR:  table "bar_table" does not exist
DROP TABLE baz_table;
CREATE TABLE savepoints (a int) distributed randomly;
BEGIN;
INSERT INTO savepoints VALUES (4);
SAVEPOINT one;
INSERT INTO savepoints VALUES (5);
COMMIT;
SELECT * FROM savepoints;
 a 
---
 4
 5
(2 rows)

BEGIN;
INSERT INTO savepoints VALUES (6);
SAVEPOINT one;
INSERT INTO savepoints VALUES (7);
RELEASE SAVEPOINT one;
INSERT INTO savepoints VALUES (8);
COMMIT;
BEGIN;
INSERT INTO savepoints VALUES (9);
SAVEPOINT one;
INSERT INTO savepoints VALUES (10);
ROLLBACK TO SAVEPOINT one;
INSERT INTO savepoints VALUES (11);
COMMIT;
SELECT a FROM savepoints WHERE a in (9, 10, 11);
 a  
----
  9
 11
(2 rows)

DROP TABLE savepoints;
BEGIN;
SAVEPOINT one;
SELECT 0/0;
ERROR:  division by zero
SAVEPOINT two;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
RELEASE SAVEPOINT one;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK TO SAVEPOINT one;
SELECT 1;
 ?column? 
----------
        1
(1 row)

COMMIT;
SELECT 1;
 ?column? 
----------
        1
(1 row)

BEGIN;
CREATE TABLE tenk1 (a int) distributed randomly;
INSERT INTO tenk1 (a) values (1), (2);
DECLARE c CURSOR FOR SELECT * FROM tenk1;
SAVEPOINT one;
FETCH 10 FROM c;
 a 
---
 1
 2
(2 rows)

ROLLBACK TO SAVEPOINT one;
FETCH 10 FROM c;
 a 
---
(0 rows)

RELEASE SAVEPOINT one;
FETCH 10 FROM c;
 a 
---
(0 rows)

CLOSE c;
DECLARE c CURSOR FOR SELECT a/0 FROM tenk1;
SAVEPOINT two;
FETCH 10 FROM c;
ERROR:  division by zero  (seg0 slice1 127.0.0.1:50001 pid=44398)
ROLLBACK TO SAVEPOINT two;
FETCH 10 FROM c;
ERROR:  portal "c" cannot be run
ROLLBACK TO SAVEPOINT two;
RELEASE SAVEPOINT two;
FETCH 10 FROM c;
ERROR:  portal "c" cannot be run
COMMIT;
DROP TABLE tenk1;
ERROR:  table "tenk1" does not exist
CREATE TABLE xacttest_table (a int, b float);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO xacttest_table (a, b) VALUES (777, 777.777);
select * from xacttest_table;
  a  |    b    
-----+---------
 777 | 777.777
(1 row)

create or replace function max_xacttest() returns double precision language sql READS SQL DATA as
'select max(b) from xacttest_table' stable;
begin;
update xacttest_table set b = max_xacttest() + 10 where b > 0;
select * from xacttest_table;
  a  |    b    
-----+---------
 777 | 787.777
(1 row)

rollback;
create or replace function max_xacttest() returns double precision language sql READS SQL DATA as
'select max(b) from xacttest_table' volatile;
begin;
update xacttest_table set b = max_xacttest() + 10 where b > 0;
ERROR:  function cannot execute on segment because it accesses relation "public.xacttest_table"  (seg1 leopard0:27012 pid=93332)
DETAIL:  SQL function "max_xacttest" during startup
select * from xacttest_table;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
create or replace function max_xacttest() returns double precision language plpgsql READS SQL DATA as
'begin return max(b) from xacttest_table; end' stable;
begin;
update xacttest_table set b = max_xacttest() + 10 where b > 0;
select * from xacttest_table;
  a  |    b    
-----+---------
 777 | 787.777
(1 row)

rollback;
create or replace function max_xacttest() returns double precision language plpgsql READS SQL DATA as
'begin return max(b) from xacttest_table; end' volatile;
begin;
update xacttest_table set b = max_xacttest() + 10 where b > 0;
ERROR:  function cannot execute on segment because it accesses relation "public.xacttest_table"  (seg1 leopard0:27012 pid=93332)
DETAIL:  
	 SQL statement "SELECT  max(b) from xacttest_table"
PL/pgSQL function "max_xacttest" line 1 at return
select * from xacttest_table;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
rollback;
DROP Function max_xacttest();
DROP TABLE xacttest_table;
BEGIN;
savepoint x;
CREATE TABLE koju (a INT UNIQUE);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "koju_a_key" for table "koju"
INSERT INTO koju VALUES (1);
INSERT INTO koju VALUES (1);
ERROR:  duplicate key violates unique constraint "koju_a_key"  (seg0 127.0.0.1:50001 pid=45361)
rollback to x;
CREATE TABLE koju (a INT UNIQUE);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "koju_a_key" for table "koju"
INSERT INTO koju VALUES (1);
INSERT INTO koju VALUES (1);
ERROR:  duplicate key violates unique constraint "koju_a_key"  (seg0 127.0.0.1:50001 pid=45361)
ROLLBACK;
DROP TABLE foo_table;
ERROR:  table "foo_table" does not exist
DROP TABLE baz_table;
ERROR:  table "baz_table" does not exist
DROP TABLE barbaz_table;
ERROR:  table "barbaz_table" does not exist
