--
-- external tables - short and simple functional tests.
--
-- start_matchsubs
--
-- # replace return code in error message (platform specific)
--
-- m/ERROR\:\s+external table .* command ended with .* not found/
-- s/nosuchcommand\:\s*(command)? not found/nosuchcommand\: NOT FOUND/
--
-- m/ERROR\:\s+external table .* command ended with .*No such file.*/
-- s/nosuchfile\.txt\:\s*No such file (or directory)?/nosuchfile\.txt\: NO SUCH FILE/
-- m/ERROR\:\s+external table .* command ended with .*No such file.*/i
-- s/cat\: (cannot open)? nosuchfile\.txt/cat\: nosuchfile\.txt/
--
-- # remove line number - redhat
-- m/ERROR\:\s+external table .* command ended with .*NOT FOUND.*/i
-- s/\s+line \d+\://
-- # remove line number - Debian
-- m/ERROR\:\s+external table .* command ended with .*sh: 1: .*NOT FOUND.*/i
-- s/ sh: 1: / sh: /
--
-- # remove cannot open - solaris
-- m/ERROR\:\s+external table .* command ended with .*cat\: cannot open.*/i
-- s/cat\: cannot open (.*)$/cat\: $1\: NO SUCH FILE/
--
-- end_matchsubs
set optimizer_disable_missing_stats_collection = on;
CREATE TABLE REG_REGION (R_REGIONKEY INT, R_NAME CHAR(25), R_COMMENT VARCHAR(152)) DISTRIBUTED BY (R_REGIONKEY);
-- --------------------------------------
-- 'file' protocol - (only CREATE, don't SELECT - won't work on distributed installation)
-- --------------------------------------
CREATE EXTERNAL TABLE EXT_NATION  ( N_NATIONKEY  INTEGER ,
                            N_NAME       CHAR(25) ,
                            N_REGIONKEY  INTEGER ,
                            N_COMMENT    VARCHAR(152))
location ('file://@hostname@@abs_srcdir@/data/nation.tbl' )
FORMAT 'text' (delimiter '|');
CREATE EXTERNAL TABLE EXT_REGION  (LIKE REG_REGION)
location ('file://@hostname@@abs_srcdir@/data/region.tbl' )
FORMAT 'text' (delimiter '|');
-- Only tables with custom protocol should create dependency, due to a bug there
-- used to be entries created for non custom protocol tables with refobjid=0.
SELECT * FROM pg_depend WHERE refclassid = 'pg_extprotocol'::regclass and refobjid = 0;
 classid | objid | objsubid | refclassid | refobjid | refobjsubid | deptype 
---------+-------+----------+------------+----------+-------------+---------
(0 rows)

-- drop tables
DROP EXTERNAL TABLE EXT_NATION;
DROP EXTERNAL TABLE EXT_REGION;
-- start_ignore
-- --------------------------------------
-- check platform
-- --------------------------------------
drop external web table if exists check_ps;
NOTICE:  table "check_ps" does not exist, skipping
CREATE EXTERNAL WEB TABLE check_ps (x text)
execute E'( (ps -ef || ps -aux) | grep gpfdist | grep -v grep)'
on SEGMENT 0
format 'text';
drop external web table if exists check_env;
NOTICE:  table "check_env" does not exist, skipping
CREATE EXTERNAL WEB TABLE check_env (x text)
execute E'( env | sort)'
on SEGMENT 0
format 'text';
select * from check_ps;
ERROR:  external table check_ps command ended with error.  (seg0 slice1 @hostname@:50000 pid=64819)
DETAIL:  Command: execute:( (ps -ef || ps -aux) | grep gpfdist | grep -v grep)
select * from check_env;
                                                                                                                                                                                                                                      x                                                                                                                                                                                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 CLICOLOR=1
 DYLD_LIBRARY_PATH=/Users/@gpcurusername@/greenplum-db-devel/lib:/Users/@gpcurusername@/greenplum-db-devel/ext/python/lib:/opt/gcc_infrastructure/lib:/Users/@gpcurusername@/greenplum-perfmon-web-4.0.1.0/lib:/Users/@gpcurusername@/greenplum-db-devel/lib:/Users/@gpcurusername@/greenplum-db-devel/ext/python/lib:
 GPHOME=/Users/@gpcurusername@/greenplum-db-devel
 GPPERFMONHOME=/Users/@gpcurusername@/greenplum-perfmon-web-4.0.1.0
 GPROOT=/Users/@gpcurusername@
 GP_CID=0
 GP_DATABASE=regression
 GP_DATE=20110816
 GP_HADOOP_CONN_JARDIR=lib//hadoop
 GP_HADOOP_CONN_VERSION=CE_1.0.0.0
 GP_MASTER_HOST=127.0.0.1
 GP_MASTER_PORT=5432
 GP_SEGMENT_COUNT=2
 GP_SEGMENT_ID=0
 GP_SEG_DATADIR=/Users/@gpcurusername@/greenplum-db-data/dbfast1/gpseg0
 GP_SEG_PG_CONF=/Users/@gpcurusername@/greenplum-db-data/dbfast1/gpseg0/postgresql.conf
 GP_SEG_PORT=50000
 GP_SESSION_ID=438
 GP_SN=1
 GP_TIME=132701
 GP_USER=@gpcurusername@
 GP_XID=1313526180-0000006772
 HADOOP_HOME=/Users/@gpcurusername@/WorkDir/hadoop-0.20.1-dev
 HADOOP_VERSION=0.21.0
 HOME=/Users/@gpcurusername@
 JAVA_HOME=/System/Library/Frameworks/JavaVM.framework/Versions/1.6.0/Home
 LC_COLLATE=en_US.utf-8
 LC_CTYPE=en_US.utf-8
 LC_MESSAGES=C
 LC_MONETARY=C
 LC_NUMERIC=C
 LC_TIME=C
 LOGNAME=@gpcurusername@
 MAIL=/var/mail/@gpcurusername@
 MASTER_DATA_DIRECTORY=//Users/@gpcurusername@/greenplum-master/gpseg-1
 OPENSSL_CONF=/Users/@gpcurusername@/greenplum-db-devel/etc/openssl.cnf
 P4CONFIG=.p4config
 PATH=/Users/@gpcurusername@/greenplum-db-devel/bin:/Users/@gpcurusername@/greenplum-db-devel/ext/python/bin:/Users/@gpcurusername@/greenplum-db-devel/bin:/Users/@gpcurusername@/greenplum-db-devel/ext/python/bin:/opt/gcc-4.4.2/bin:/Users/@gpcurusername@/Workdir/mybin:/Users/@gpcurusername@/greenplum-perfmon-web-4.0.1.0/bin:/Users/@gpcurusername@/greenplum-db-devel/bin:/Users/@gpcurusername@/greenplum-db-devel/ext/python/bin:/Users/@gpcurusername@/greenplum-db-devel/bin:/Users/@gpcurusername@/greenplum-db-devel/ext/python/bin:/usr/bin:/bin:/usr/sbin:/sbin
 PGDATA=/Users/@gpcurusername@/greenplum-db-data/dbfast1/gpseg0
 PGHOST=127.0.0.1
 PGSYSCONFDIR=/Users/@gpcurusername@/greenplum-db-devel/etc/postgresql
 PWD=/Users/@gpcurusername@/greenplum-db-data/dbfast1/gpseg0
 PYTHONHOME=/Users/@gpcurusername@/greenplum-db-devel/ext/python
 PYTHONPATH=/Users/@gpcurusername@/greenplum-db-devel/lib/python
 SHELL=/bin/bash
 SHLVL=4
 SSH_CLIENT=127.0.0.1 50658 22
 SSH_CONNECTION=127.0.0.1 50658 127.0.0.1 22
 TERM=xterm-color
 USER=@gpcurusername@
 VERSIONER_PERL_PREFER_32_BIT=yes
 VERSIONER_PERL_VERSION=5.8.9
 ZK_HOME=/Users/@gpcurusername@/WorkDir/zookeeper-3.3.3
 _=/usr/bin/env
 __CF_USER_TEXT_ENCODING=0x1F7:0:0
(55 rows)

-- end_ignore
-- --------------------------------------
-- some negative tests
-- --------------------------------------
--
-- test for exec child process stderr showing in error message
--
create external web table ext_stderr1(a text) execute 'nosuchcommand' format 'text';
create external web table ext_stderr2(a text) execute 'cat nosuchfile.txt' format 'text';
select * from ext_stderr1;
ERROR:  external table ext_stderr1 command ended with error. sh: nosuchcommand: command not found  (seg0 slice1 @hostname@:50000 pid=64819)
DETAIL:  Command: execute:nosuchcommand
select * from ext_stderr2;
ERROR:  external table ext_stderr2 command ended with error. cat: nosuchfile.txt: No such file or directory  (seg0 slice1 @hostname@:50000 pid=64819)
DETAIL:  Command: execute:cat nosuchfile.txt
drop external web table ext_stderr1;
drop external web table ext_stderr2;
--
-- bad csv (quote must be a single char)
--
create external table bad_whois (
source_lineno			int,
domain_name			varchar(350)
)
location ('gpfdist://@hostname@:7070/exttab1/whois.csv' )
format 'csv' ( header quote as 'ggg');
NOTICE:  HEADER means that each one of the data files has a header row.
ERROR:  quote must be a single character
select count(*) from bad_whois;
ERROR:  relation "bad_whois" does not exist
LINE 1: select count(*) from bad_whois;
                             ^
drop external table bad_whois;
ERROR:  table "bad_whois" does not exist
--
-- try a bad location
--
create external table badt1 (x text) 
location ('file://@hostname@@abs_srcdir@/data/no/such/place/badt1.tbl' )
format 'text' (delimiter '|');
select * from badt1;
NOTICE:  gfile stat @abs_srcdir@/data/no/such/place/badt1.tbl failure: No such file or directory  (seg0 slice1 @hostname@:50000 pid=64819)
NOTICE:  fstream unable to open file @abs_srcdir@/data/no/such/place/badt1.tbl  (seg0 slice1 @hostname@:50000 pid=64819)
ERROR:  could not open "file://@hostname@@abs_srcdir@/data/no/such/place/badt1.tbl" for reading: 404 file not found  (seg0 slice1 @hostname@:50000 pid=64819)
drop external table badt1;
--
-- try a bad protocol
--
create external table badt2 (x text) 
location ('bad_protocol://@hostname@@abs_srcdir@/data/no/such/place/badt2.tbl' )
format 'text' (delimiter '|');
ERROR:  protocol "bad_protocol" does not exist
--
-- ALTER (partial support)
--
create external table ext (a int, x text) 
location ('file://@hostname@@abs_srcdir@/data/no/such/place/badt1.tbl' )
format 'text';
alter table ext drop column a; -- should pass with warning
WARNING:  "ext" is an external table. ALTER TABLE for external tables is deprecated.
HINT:  Use ALTER EXTERNAL TABLE instead
alter external table ext add column a int; -- pass
alter external table ext drop column a; -- pass
alter external table ext add column extnewcol int not null; -- should fail (constraints not allowed)
ERROR:  Unsupported ALTER command for table type external
alter external table ext add column extnewcol int; -- pass
alter external table ext alter column extnewcol set default 1; -- should fail (unsupported alter type)
ERROR:  Unsupported ALTER command for table type external
--
-- TRUNCATE/UPDATE/DELETE/INSERT (INTO RET)
--
truncate ext;
ERROR:  "ext" is an external relation and can't be truncated
delete from ext;
ERROR:  cannot update or delete from external relation "ext"
update ext set x='1' where x='2';
ERROR:  cannot update or delete from external relation "ext"
insert into ext(x) values('a');
ERROR:  cannot change a readable external table "ext"
drop table ext; -- should fail (wrong object)
ERROR:  "ext" is not a base table
HINT:  Use DROP EXTERNAL TABLE to remove an external table
drop external table ext;
----------------------------------------------------------------------
-- CUSTOM PROTOCOLS
----------------------------------------------------------------------
DROP EXTERNAL TABLE IF EXISTS ext_w;
NOTICE:  table "ext_w" does not exist, skipping
DROP EXTERNAL TABLE IF EXISTS ext_r;
NOTICE:  table "ext_r" does not exist, skipping
DROP ROLE IF EXISTS extprotu;
NOTICE:  role "extprotu" does not exist, skipping
NOTICE:  role "extprotu" does not exist, skipping  (seg0 @hostname@:50000 pid=64819)
NOTICE:  role "extprotu" does not exist, skipping  (seg1 @hostname@:50001 pid=64820)
CREATE OR REPLACE FUNCTION write_to_file() RETURNS integer as '$libdir/gpextprotocol.so', 'demoprot_export' LANGUAGE C STABLE NO SQL;
CREATE OR REPLACE FUNCTION read_from_file() RETURNS integer as '$libdir/gpextprotocol.so', 'demoprot_import' LANGUAGE C STABLE NO SQL;
DROP PROTOCOL IF EXISTS demoprot;
NOTICE:  protocol "demoprot" does not exist, skipping
CREATE TRUSTED PROTOCOL demoprot (readfunc = 'nosuchfunc'); -- should fail
ERROR:  function nosuchfunc() does not exist
CREATE TRUSTED PROTOCOL demoprot (readfunc = 'boolin'); -- should fail
ERROR:  function boolin() does not exist
CREATE TRUSTED PROTOCOL demoprot (readfunc = 'read_from_file', writefunc = 'write_to_file'); -- should succeed
CREATE PROTOCOL demoprot_untrusted (readfunc = 'read_from_file', writefunc = 'write_to_file'); -- should succeed
ALTER PROTOCOL demoprot_untrusted RENAME TO demoprot_untrusted2;
ALTER PROTOCOL demoprot_untrusted2 RENAME TO demoprot_untrusted;
CREATE ROLE extprotu NOSUPERUSER;
NOTICE:  resource queue required -- using default resource queue "pg_default"
SET SESSION AUTHORIZATION extprotu;
CREATE WRITABLE EXTERNAL TABLE ext_w(a int) location('demoprot://demoprotfile.txt') format 'text'; -- should fail
ERROR:  permission denied for external protocol demoprot
CREATE READABLE EXTERNAL TABLE ext_r(a int) location('demoprot://demoprotfile.txt') format 'text'; -- should fail
ERROR:  permission denied for external protocol demoprot
RESET SESSION AUTHORIZATION;
ALTER PROTOCOL demoprot_untrusted OWNER TO extprotu; -- should fail. protocol is not trusted
ERROR:  untrusted protocol "demoprot_untrusted" can't be owned by non superuser
GRANT SELECT ON PROTOCOL demoprot_untrusted TO extprotu; -- should fail. protocol is not trusted
ERROR:  protocol "demoprot_untrusted" is not trusted
HINT:  Only superusers may use untrusted protocols.
GRANT SELECT ON PROTOCOL demoprot TO extprotu;
GRANT INSERT ON PROTOCOL demoprot TO extprotu;
SET SESSION AUTHORIZATION extprotu;
CREATE WRITABLE EXTERNAL TABLE ext_w(a int) location('demoprot://demoprotfile.txt') format 'text'; -- should succeed
-- For tables using custom protocol should have dependency
SELECT count(*) FROM pg_depend WHERE refclassid = 'pg_extprotocol'::regclass and objid = 'ext_w'::regclass;
 count 
-------
     1
(1 row)

CREATE READABLE EXTERNAL TABLE ext_r(a int) location('demoprot://demoprotfile.txt') format 'text'; -- should succeed
-- For tables using custom protocol should have dependency
SELECT count(*) FROM pg_depend WHERE refclassid = 'pg_extprotocol'::regclass and objid = 'ext_r'::regclass;
 count 
-------
     1
(1 row)

DROP EXTERNAL TABLE IF EXISTS ext_w;
DROP EXTERNAL TABLE IF EXISTS ext_r;
RESET SESSION AUTHORIZATION;
REVOKE INSERT ON PROTOCOL demoprot FROM extprotu;
SET SESSION AUTHORIZATION extprotu;
CREATE WRITABLE EXTERNAL TABLE ext_w(a int) location('demoprot://demoprotfile.txt') format 'text'; -- should fail
ERROR:  permission denied for external protocol demoprot
CREATE READABLE EXTERNAL TABLE ext_r(a int) location('demoprot://demoprotfile.txt') format 'text'; -- should succeed
DROP EXTERNAL TABLE ext_r;
RESET SESSION AUTHORIZATION;
REVOKE ALL PRIVILEGES ON PROTOCOL demoprot FROM extprotu;
DROP ROLE IF EXISTS extprotu;
--
-- WET tests
--
--
-- CREATE (including LIKE, DISTRIBUTED BY)
--
-- positive
create writable external web table wet_pos4(a text, b text) execute 'some command' format 'text';
-- negative
create writable external table wet_neg1(a text, b text) location('file://@hostname@@abs_srcdir@/badt1.tbl') format 'text';
ERROR:  unsupported URI protocol 'file' for writable external table
HINT:  Writable external tables may use 'gpfdist', 'gpfdists' or 'gphdfs' URIs only.
create writable external table wet_neg1(a text, b text) location('gpfdist://foo:7070/wet.out', 'gpfdist://foo:7070/wet.out') format 'text';
ERROR:  duplicate location uri
LINE 1: ...t, b text) location('gpfdist://foo:7070/wet.out', 'gpfdist:/...
                                                             ^
create writable external web table wet_pos5(a text, b text) execute 'some command' on segment 0 format 'text';
ERROR:  ON clause may not be used with a writable external table
--
-- test CREATE EXTERNAL TABLE privileges
--
show gp_external_grant_privileges; -- MUST BE OFF for the following tests to work.
 gp_external_grant_privileges 
------------------------------
 off
(1 row)

CREATE ROLE exttab1_su SUPERUSER; -- SU with no privs in pg_auth
CREATE ROLE exttab1_u1 CREATEEXTTABLE(protocol='gpfdist', type='readable'); 
NOTICE:  resource queue required -- using default resource queue "pg_default"
CREATE ROLE exttab1_u2 CREATEEXTTABLE(protocol='gpfdist', type='writable'); 
NOTICE:  resource queue required -- using default resource queue "pg_default"
CREATE ROLE exttab1_u3 CREATEEXTTABLE(protocol='gpfdist') NOCREATEEXTTABLE(protocol='gpfdist', type='readable'); -- fail due to conflict 
NOTICE:  resource queue required -- using default resource queue "pg_default"
ERROR:  conflicting specifications in CREATEEXTTABLE and NOCREATEEXTTABLE
CREATE ROLE exttab1_u4 CREATEEXTTABLE(protocol='gphdfs', type='readable'); 
WARNING:  GRANT/REVOKE on gphdfs is deprecated
HINT:  Issue the GRANT or REVOKE on the protocol itself
NOTICE:  resource queue required -- using default resource queue "pg_default"
WARNING:  GRANT/REVOKE on gphdfs is deprecated  (seg1 @hostname@:50001 pid=64820)
HINT:  Issue the GRANT or REVOKE on the protocol itself
WARNING:  GRANT/REVOKE on gphdfs is deprecated  (seg0 @hostname@:50000 pid=64819)
HINT:  Issue the GRANT or REVOKE on the protocol itself
CREATE ROLE exttab1_u5 CREATEEXTTABLE(protocol='gphdfs', type='writable'); 
WARNING:  GRANT/REVOKE on gphdfs is deprecated
HINT:  Issue the GRANT or REVOKE on the protocol itself
NOTICE:  resource queue required -- using default resource queue "pg_default"
WARNING:  GRANT/REVOKE on gphdfs is deprecated  (seg0 @hostname@:50000 pid=64819)
HINT:  Issue the GRANT or REVOKE on the protocol itself
WARNING:  GRANT/REVOKE on gphdfs is deprecated  (seg1 @hostname@:50001 pid=64820)
HINT:  Issue the GRANT or REVOKE on the protocol itself
CREATE ROLE exttab1_u6 NOCREATEEXTTABLE(protocol='gphdfs', type='readable') NOCREATEEXTTABLE(protocol='gphdfs', type='writable');
WARNING:  GRANT/REVOKE on gphdfs is deprecated
HINT:  Issue the GRANT or REVOKE on the protocol itself
WARNING:  GRANT/REVOKE on gphdfs is deprecated
HINT:  Issue the GRANT or REVOKE on the protocol itself
NOTICE:  resource queue required -- using default resource queue "pg_default"
WARNING:  GRANT/REVOKE on gphdfs is deprecated  (seg1 @hostname@:50001 pid=64820)
HINT:  Issue the GRANT or REVOKE on the protocol itself
WARNING:  GRANT/REVOKE on gphdfs is deprecated  (seg0 @hostname@:50000 pid=64819)
HINT:  Issue the GRANT or REVOKE on the protocol itself
WARNING:  GRANT/REVOKE on gphdfs is deprecated  (seg0 @hostname@:50000 pid=64819)
HINT:  Issue the GRANT or REVOKE on the protocol itself
WARNING:  GRANT/REVOKE on gphdfs is deprecated  (seg1 @hostname@:50001 pid=64820)
HINT:  Issue the GRANT or REVOKE on the protocol itself
CREATE ROLE exttab1_u7 CREATEEXTTABLE(protocol='gphdfs') NOCREATEEXTTABLE(protocol='gphdfs', type='readable'); -- fail due to conflict 
WARNING:  GRANT/REVOKE on gphdfs is deprecated
HINT:  Issue the GRANT or REVOKE on the protocol itself
WARNING:  GRANT/REVOKE on gphdfs is deprecated
HINT:  Issue the GRANT or REVOKE on the protocol itself
NOTICE:  resource queue required -- using default resource queue "pg_default"
ERROR:  conflicting specifications in CREATEEXTTABLE and NOCREATEEXTTABLE
CREATE ROLE exttab1_u7 CREATEEXTTABLE(protocol='gphdfs', type='writable') NOCREATEEXTTABLE(protocol='gphdfs', type='writable'); -- fail due to conflict 
WARNING:  GRANT/REVOKE on gphdfs is deprecated
HINT:  Issue the GRANT or REVOKE on the protocol itself
WARNING:  GRANT/REVOKE on gphdfs is deprecated
HINT:  Issue the GRANT or REVOKE on the protocol itself
NOTICE:  resource queue required -- using default resource queue "pg_default"
ERROR:  conflicting specifications in CREATEEXTTABLE and NOCREATEEXTTABLE
SET SESSION AUTHORIZATION exttab1_su;
create readable external table auth_ext_test1(a int) location ('gpfdist://host:8000/file') format 'text';
SET SESSION AUTHORIZATION exttab1_u1;
create readable external table auth_ext_test2(a int) location ('gpfdist://host:8000/file') format 'text';
create writable external table auth_ext_test3(a int) location ('gpfdist://host:8000/file') format 'text'; -- fail
ERROR:  permission denied: no privilege to create a writable gpfdist(s) external table
SET SESSION AUTHORIZATION exttab1_u2;
create writable external table auth_ext_test3(a int) location ('gpfdist://host:8000/file') format 'text';
RESET SESSION AUTHORIZATION;
ALTER ROLE exttab1_u2 NOCREATEEXTTABLE(protocol='gpfdist', type='writable');
SET SESSION AUTHORIZATION exttab1_u2;
create writable external table auth_ext_test4(a int) location ('gpfdist://host:8000/file') format 'text'; -- fail
ERROR:  permission denied: no privilege to create a writable gpfdist(s) external table
RESET SESSION AUTHORIZATION;
drop external table auth_ext_test1;
drop external table auth_ext_test2;
drop external table auth_ext_test3;
drop external table auth_ext_test5;
ERROR:  table "auth_ext_test5" does not exist
drop external table auth_ext_test7;
ERROR:  table "auth_ext_test7" does not exist
DROP ROLE exttab1_su;
DROP ROLE exttab1_u1;
DROP ROLE exttab1_u2;
DROP ROLE exttab1_u4;
DROP ROLE exttab1_u5;
DROP ROLE exttab1_u6;
drop external table check_ps;
drop external table check_env;
drop external table wet_pos4;
-- Dropping an external table, both via DROP EXTERNAL TABLE and as a result
-- from a cascading deletion must result in the deletion of the relation
-- pg_exttable row.
CREATE EXTERNAL WEB TABLE cascadetest (x text) EXECUTE 'echo "cascadetest";' FORMAT 'text';
SELECT count(*) FROM pg_exttable WHERE command = 'echo "cascadetest";';
 count 
-------
     1
(1 row)

DROP EXTERNAL TABLE cascadetest;
SELECT count(*) FROM pg_exttable WHERE command = 'echo "cascadetest";';
 count 
-------
     0
(1 row)

CREATE SCHEMA exttabletest;
CREATE
	EXTERNAL TABLE exttabletest.ext_nation (n_nationkey integer, n_name char(25), n_regionkey integer, n_comment varchar(152))
	LOCATION ('file://@hostname@@abs_srcdir@/data/nation.tbl') FORMAT 'text' (delimiter '|');
SELECT count(*) FROM pg_exttable WHERE location @> '{file://@hostname@@abs_srcdir@/data/nation.tbl}';
 count 
-------
     1
(1 row)

DROP SCHEMA exttabletest CASCADE;
NOTICE:  drop cascades to external table exttabletest.ext_nation
SELECT count(*) FROM pg_exttable WHERE location @> '{file://@hostname@@abs_srcdir@/data/nation.tbl}';
 count 
-------
     0
(1 row)

-- Tests for MPP17980: generating artificial CTIDs for external table scans
-- This is necessary because the planner currently generates plans that include
-- the CTID attribute for external tables.
CREATE EXTERNAL TABLE ext_mpp17980 ( id int , id1 int , id2 int)
LOCATION ('file://@hostname@@abs_srcdir@/data/mpp17980.data')
FORMAT 'CSV' ( DELIMITER ',' NULL ' ');
CREATE TABLE mpp17980 (id int, date date, amt decimal(10,2))
DISTRIBUTED randomly PARTITION BY RANGE (date)
( START (date '2008-01-01') INCLUSIVE  END (date '2009-01-01') EXCLUSIVE
EVERY (INTERVAL '1 month') );
NOTICE:  CREATE TABLE will create partition "mpp17980_1_prt_1" for table "mpp17980"
NOTICE:  CREATE TABLE will create partition "mpp17980_1_prt_2" for table "mpp17980"
NOTICE:  CREATE TABLE will create partition "mpp17980_1_prt_3" for table "mpp17980"
NOTICE:  CREATE TABLE will create partition "mpp17980_1_prt_4" for table "mpp17980"
NOTICE:  CREATE TABLE will create partition "mpp17980_1_prt_5" for table "mpp17980"
NOTICE:  CREATE TABLE will create partition "mpp17980_1_prt_6" for table "mpp17980"
NOTICE:  CREATE TABLE will create partition "mpp17980_1_prt_7" for table "mpp17980"
NOTICE:  CREATE TABLE will create partition "mpp17980_1_prt_8" for table "mpp17980"
NOTICE:  CREATE TABLE will create partition "mpp17980_1_prt_9" for table "mpp17980"
NOTICE:  CREATE TABLE will create partition "mpp17980_1_prt_10" for table "mpp17980"
NOTICE:  CREATE TABLE will create partition "mpp17980_1_prt_11" for table "mpp17980"
NOTICE:  CREATE TABLE will create partition "mpp17980_1_prt_12" for table "mpp17980"
INSERT INTO mpp17980 VALUES ( 1,'2008-02-20',122.11);
SELECT COUNT(*) FROM ext_mpp17980 WHERE id IN ( 1 ) ;  -- This returns 18 tuples
 count
-------
    18
(1 row)

SELECT COUNT(*) FROM ext_mpp17980 WHERE id IN ( SELECT id FROM mpp17980 ) ; -- This should return 18 tuples but returns only 1
 count
-------
    18
(1 row)

SELECT ctid, * FROM ext_mpp17980;
  ctid  | id | id1 | id2
--------+----+-----+-----
 (0,1)  |  1 |   1 |   1
 (0,2)  |  1 |   2 |   2
 (0,3)  |  1 |   2 |   3
 (0,4)  |  1 |   3 |   4
 (0,5)  |  1 |   2 |   3
 (0,6)  |  1 |   1 |   1
 (0,7)  |  1 |   2 |   3
 (0,8)  |  1 |   2 |   3
 (0,9)  |  1 |   1 |   1
 (0,10) |  1 |   1 |   1
 (0,11) |  1 |   2 |   2
 (0,12) |  1 |   2 |   3
 (0,13) |  1 |   3 |   4
 (0,14) |  1 |   2 |   3
 (0,15) |  1 |   1 |   1
 (0,16) |  1 |   2 |   3
 (0,17) |  1 |   2 |   3
 (0,18) |  1 |   1 |   1
(18 rows)

DROP EXTERNAL TABLE ext_mpp17980;
DROP TABLE mpp17980;
COPY (VALUES('1,2'),('1,2,3'),('1,'),('1')) TO '@abs_srcdir@/data/tableless.csv';
CREATE TABLE tableless_heap(a int, b int);
COPY tableless_heap FROM '@abs_srcdir@/data/tableless.csv' CSV LOG ERRORS SEGMENT REJECT LIMIT 10;
NOTICE:  Found 2 data formatting errors (2 or more input rows). Rejected related input data.
SELECT relname, linenum, errmsg FROM gp_read_error_log('tableless_heap');
    relname     | linenum |                errmsg                 
----------------+---------+---------------------------------------
 tableless_heap |       2 | extra data after last expected column
 tableless_heap |       4 | missing data for column "b"
(2 rows)

create table errlog_save as select * from gp_read_error_log('tableless_heap');
select count(*) from errlog_save;
 count 
-------
     2
(1 row)

SELECT gp_truncate_error_log('tableless_heap');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT relname, linenum, errmsg FROM gp_read_error_log('tableless_heap');
 relname | linenum | errmsg 
---------+---------+--------
(0 rows)

create external table tableless_ext(a int, b int)
location ('file://@hostname@@abs_srcdir@/data/tableless.csv')
format 'csv'
log errors segment reject limit 10;
select * from tableless_ext;
NOTICE:  Found 2 data formatting errors (2 or more input rows). Rejected related input data.
 a | b 
---+---
 1 |  
 1 | 2
(2 rows)

SELECT relname, linenum, errmsg FROM gp_read_error_log('tableless_ext');
    relname    | linenum |                errmsg                 
---------------+---------+---------------------------------------
 tableless_ext |       2 | extra data after last expected column
 tableless_ext |       4 | missing data for column "b"
(2 rows)

SELECT (gp_read_error_log('tableless_ext')).errmsg;
                errmsg                 
---------------------------------------
 extra data after last expected column
 missing data for column "b"
(2 rows)

SELECT gp_truncate_error_log('tableless_ext');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT relname, linenum, errmsg FROM gp_read_error_log('tableless_ext');
 relname | linenum | errmsg 
---------+---------+--------
(0 rows)

select * from tableless_ext;
NOTICE:  Found 2 data formatting errors (2 or more input rows). Rejected related input data.
 a | b 
---+---
 1 |  
 1 | 2
(2 rows)

SELECT gp_truncate_error_log('*');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

select * from tableless_ext;
NOTICE:  Found 2 data formatting errors (2 or more input rows). Rejected related input data.
 a | b 
---+---
 1 |  
 1 | 2
(2 rows)

SELECT gp_truncate_error_log('*.*');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT relname, linenum, errmsg FROM gp_read_error_log('tableless_ext');
 relname | linenum | errmsg 
---------+---------+--------
(0 rows)

-- Verify that the error log functions are a part of the catalog
-- Earlier these functions were hidden from the catalog and would not show up
-- in pg_proc
SELECT * from pg_proc where proname = 'gp_read_error_log';
      proname      | pronamespace | proowner | prolang | procost | prorows | provariadic | proisagg | prosecdef | proisstrict | proretset | provolatile | pronargs | pronargdefaults | prorettype | proiswin | proargtypes |         proallargtypes         |     proargmodes     |                                 proargnames                                 | proargdefaults |      prosrc       | probin | proconfig | proacl | prodataaccess 
-------------------+--------------+----------+---------+---------+---------+-------------+----------+-----------+-------------+-----------+-------------+----------+-----------------+------------+----------+-------------+--------------------------------+---------------------+-----------------------------------------------------------------------------+----------------+-------------------+--------+-----------+--------+---------------
 gp_read_error_log |           11 |       10 |      12 |       1 |    1000 |           0 | f        | f         | t           | t         | v           |        1 |               0 |       2249 | f        | 25          | {25,1184,25,25,23,23,25,25,17} | {i,o,o,o,o,o,o,o,o} | {exttable,cmdtime,relname,filename,linenum,bytenum,errmsg,rawdata,rawbytes} |                | gp_read_error_log |        |           |        | s
(1 row)

SELECT * from pg_proc where proname = 'gp_truncate_error_log';
        proname        | pronamespace | proowner | prolang | procost | prorows | provariadic | proisagg | prosecdef | proisstrict | proretset | provolatile | pronargs | pronargdefaults | prorettype | proiswin | proargtypes | proallargtypes | proargmodes | proargnames | proargdefaults |        prosrc         | probin | proconfig | proacl | prodataaccess 
-----------------------+--------------+----------+---------+---------+---------+-------------+----------+-----------+-------------+-----------+-------------+----------+-----------------+------------+----------+-------------+----------------+-------------+-------------+----------------+-----------------------+--------+-----------+--------+---------------
 gp_truncate_error_log |           11 |       10 |      12 |       1 |       0 |           0 | f        | f         | t           | f         | v           |        1 |               0 |         16 | f        | 25          |                |             |             |                | gp_truncate_error_log |        |           |        | m
(1 row)

-- Test for error log functionality 
-- Scan with no errors
CREATE EXTERNAL TABLE exttab_basic_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
-- Empty error log 
SELECT * FROM gp_read_error_log('exttab_basic_1'); 
 cmdtime | relname | filename | linenum | bytenum | errmsg | rawdata | rawbytes 
---------+---------+----------+---------+---------+--------+---------+----------
(0 rows)

SELECT COUNT(*) FROM exttab_basic_1;
 count 
-------
    10
(1 row)

-- Error log should still be empty
SELECT * FROM gp_read_error_log('exttab_basic_1');
 cmdtime | relname | filename | linenum | bytenum | errmsg | rawdata | rawbytes 
---------+---------+----------+---------+---------+--------+---------+----------
(0 rows)

-- Some errors without exceeding reject limit
CREATE EXTERNAL TABLE exttab_basic_2( i int, j text )
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|')
LOG ERRORS SEGMENT REJECT LIMIT 10;
-- should not error out as segment reject limit will not be reached
SELECT * FROM exttab_basic_2 order by i;
NOTICE:  Found 2 data formatting errors (2 or more input rows). Rejected related input data.
 i  |     j     
----+-----------
  1 | 1_number
  2 | 2_number
  4 | 4_number
  6 | 6_number
  7 | 7_number
  8 | 8_number
  9 | 9_number
 10 | 10_number
(8 rows)

-- Error rows logged
select count(*) from gp_read_error_log('exttab_basic_2');
 count 
-------
     2
(1 row)

-- Errors with exceeding reject limit
CREATE EXTERNAL TABLE exttab_basic_3( i int, j text )
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|')
LOG ERRORS SEGMENT REJECT LIMIT 2;
-- should error out as segment reject limit will be reached
SELECT * FROM exttab_basic_3;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice1 @hostname@:40000 pid=95343)
DETAIL:  External table exttab_basic_3, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
-- Error log should be populated
select count(*) > 0 from gp_read_error_log('exttab_basic_3');
 ?column? 
----------
 t
(1 row)

-- Insert into another table
CREATE EXTERNAL TABLE exttab_basic_4( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 100;
CREATE TABLE exttab_insert_1 (LIKE exttab_basic_4);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
-- Insert should go through fine
INSERT INTO exttab_insert_1 SELECT * FROM exttab_basic_4;
NOTICE:  Found 6 data formatting errors (6 or more input rows). Rejected related input data.
-- Error log should be populated
select count(*) > 0 from gp_read_error_log('exttab_basic_4');
 ?column? 
----------
 t
(1 row)

-- Use the same error log above
CREATE EXTERNAL TABLE exttab_basic_5( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 5;
-- Insert should fail
INSERT INTO exttab_insert_1 select * from exttab_basic_5;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice1 @hostname@:40000 pid=95610)
DETAIL:  External table exttab_basic_5, line 18 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
SELECT * from exttab_insert_1 order by i;
 i  |     j     
----+-----------
  1 | 1_number
  2 | 2_number
  3 | 3_number
  4 | 4_number
  6 | 6_number
  7 | 7_number
  8 | 8_number
  9 | 9_number
 10 | 10_number
 11 | 11_number
 12 | 12_number
 13 | 13_number
 14 | 14_number
 15 | 15_number
(14 rows)

-- Error log should have additional rows that were rejected by the above query
SELECT count(*) from gp_read_error_log('exttab_basic_5');
 count 
-------
     4
(1 row)

-- CTAS
CREATE EXTERNAL TABLE exttab_basic_6( i int, j text )
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|')
LOG ERRORS SEGMENT REJECT LIMIT 100;
CREATE TABLE exttab_ctas_1 as SELECT * FROM exttab_basic_6;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  Found 6 data formatting errors (6 or more input rows). Rejected related input data.
-- CTAS should go through fine
SELECT * FROM exttab_ctas_1 order by i;
 i  |     j     
----+-----------
  1 | 1_number
  2 | 2_number
  3 | 3_number
  4 | 4_number
  6 | 6_number
  7 | 7_number
  8 | 8_number
  9 | 9_number
 10 | 10_number
 11 | 11_number
 12 | 12_number
 13 | 13_number
 14 | 14_number
 15 | 15_number
(14 rows)

-- Error log should have six rows that were rejected
select count(*) from gp_read_error_log('exttab_basic_6');
 count 
-------
     6
(1 row)

CREATE EXTERNAL TABLE exttab_basic_7( i int, j text )
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|')
LOG ERRORS SEGMENT REJECT LIMIT 5;
-- CTAS should fail
CREATE TABLE exttab_ctas_2 AS select * from exttab_basic_7;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice1 @hostname@:40000 pid=95610)
DETAIL:  External table exttab_basic_7, line 18 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
-- Table should not exist
SELECT * from exttab_ctas_2 order by i;
ERROR:  relation "exttab_ctas_2" does not exist
LINE 1: SELECT * from exttab_ctas_2 order by i;
                      ^
-- Error table should have additional rows that were rejected by the above query
SELECT count(*) from gp_read_error_log('exttab_basic_7');
 count 
-------
     4
(1 row)

-- pg_exttable.fmterrtbl references to itself for external table with error logs
CREATE EXTERNAL TABLE exttab_error_log( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
SELECT reloid = fmterrtbl FROM pg_exttable
WHERE reloid = (SELECT oid from pg_class where relname ilike 'exttab_error_log');
 ?column? 
----------
 t
(1 row)

-- Drop external table gets rid off error logs
DROP EXTERNAL TABLE IF EXISTS exttab_error_log;
NOTICE:  table "exttab_error_log" does not exist, skipping
CREATE EXTERNAL TABLE exttab_error_log( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
SELECT COUNT(*) FROM exttab_error_log;
 count 
-------
    10
(1 row)

SELECT COUNT(*) FROM gp_read_error_log('exttab_error_log');
 count 
-------
     0
(1 row)

DROP EXTERNAL TABLE exttab_error_log;
SELECT COUNT(*) FROM gp_read_error_log('exttab_error_log');
 count 
-------
     0
(1 row)

-- Insert into another table with unique constraints
CREATE EXTERNAL TABLE exttab_constraints_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
-- Should not error out
SELECT COUNT(*) FROM exttab_constraints_1;
 count 
-------
    10
(1 row)

-- Error log should have a couple of rows
SELECT COUNT(*) from gp_read_error_log('exttab_constraints_1');
 count 
-------
     0
(1 row)

CREATE TABLE exttab_constraints_insert_1 (LIKE exttab_constraints_1) distributed by (i);
ALTER TABLE exttab_constraints_insert_1 ADD CONSTRAINT exttab_uniq_constraint_1 UNIQUE (j);
NOTICE:  updating distribution policy to match new unique index
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "exttab_constraints_insert_1_j_key" for table "exttab_constraints_insert_1"
-- This should fail
select gp_truncate_error_log('exttab_constraints_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

INSERT INTO exttab_constraints_insert_1 SELECT * FROM exttab_constraints_1;
SELECT COUNT(*) FROM gp_read_error_log('exttab_constraints_1');
 count 
-------
     0
(1 row)

-- CTE with segment reject limit reached
-- does not reach reject limit
CREATE EXTERNAL TABLE exttab_cte_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
-- reaches reject limit, use the same err table
CREATE EXTERNAL TABLE exttab_cte_2( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
with cte1 as 
(
SELECT e1.i, e2.j FROM exttab_cte_2 e1, exttab_cte_1 e2
WHERE e1.i = e2.i ORDER BY e1.i
)
SELECT * FROM cte1 ORDER BY cte1.i;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice2 @hostname@:40000 pid=95621)
DETAIL:  External table exttab_cte_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
select count(*) from gp_read_error_log('exttab_cte_2');
 count 
-------
     1
(1 row)

select count(*) from gp_read_error_log('exttab_cte_1');
 count 
-------
     2
(1 row)

-- CTE without segment reject limit exceeded
select gp_truncate_error_log('exttab_cte_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

select gp_truncate_error_log('exttab_cte_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

with cte1 as
(
SELECT e1.i, e2.j FROM exttab_cte_1 e1, exttab_cte_1 e2 WHERE e1.i = e2.i AND e1.i > 5 ORDER BY e1.i
)
SELECT  cte1.i , cte1.j FROM cte1 ORDER BY cte1.i;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 i  |     j     
----+-----------
  6 | 6_number
  7 | 7_number
  8 | 8_number
  9 | 9_number
 10 | 10_number
(5 rows)

select count(*) from gp_read_error_log('exttab_cte_1');
 count 
-------
     4
(1 row)

-- Define a cursor on an external table scan query with segment reject limit reached
-- does not reach reject limit
CREATE EXTERNAL TABLE exttab_cursor_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
-- reaches reject limit, use the same err table
CREATE EXTERNAL TABLE exttab_cursor_2( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
-- Test to make sure error logs are populated when cursors are used
-- The total number of formatting errors reported by the query is dependant on the number of rows parsed on
-- the segments before COMMIT finishes. So mask the NOTICE by setting the client_min_messages guc to WARNING.
set CLIENT_MIN_MESSAGES=WARNING;
BEGIN;
DECLARE exttab_cur1 no scroll cursor FOR
SELECT e1.i, e2.j from exttab_cursor_1 e1 INNER JOIN exttab_cursor_1 e2 ON e1.i = e2.i
UNION ALL
SELECT e1.i, e2.j from exttab_cursor_1 e1 INNER JOIN exttab_cursor_1 e2 ON e1.i = e2.i
UNION ALL
SELECT e1.i, e2.j from exttab_cursor_1 e1 INNER JOIN exttab_cursor_1 e2 ON e1.i = e2.i;
COMMIT;
-- This should have the errors populated already
SELECT count(*) > 0 FROM gp_read_error_log('exttab_cursor_1');
 ?column? 
----------
 t
(1 row)

reset CLIENT_MIN_MESSAGES;
-- Fetch on external table scans with segment reject limit reached
SELECT gp_truncate_error_log('exttab_cursor_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_cursor_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

-- DECLARE CURSOR implicitly initiates a FETCH on the segments. If one of
-- the segments reaches the reject limit and reports the error back to the QD
-- before the others, the transaction gets aborted. The timing of fetching the
-- results will  influence the order of the ERROR in the output.
BEGIN;
DECLARE exttab_cur1 no scroll cursor FOR
SELECT e1.i, e2.j from exttab_cursor_2 e1 INNER JOIN exttab_cursor_2 e2 ON e1.i = e2.i
UNION ALL
SELECT e1.i, e2.j from exttab_cursor_2 e1 INNER JOIN exttab_cursor_2 e2 ON e1.i = e2.i
UNION ALL
SELECT e1.i, e2.j from exttab_cursor_2 e1 INNER JOIN exttab_cursor_2 e2 ON e1.i = e2.i;
-- Should not fail as we would not have reached segment reject limit yet. This fails currently though
-- because how cursors scan the rows internally is implementation dependant. 
-- The test is here to track the issue.
FETCH exttab_cur1;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice1 subraa4-mac:40000 pid=70279)
DETAIL:  External table exttab_cursor_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
COMMIT;
-- This should have errors populated already
SELECT count(*) > 0 FROM gp_read_error_log('exttab_cursor_2');
 ?column? 
----------
 t
(1 row)

-- Fetch on external table scans without reaching segment reject limit
SELECT gp_truncate_error_log('exttab_cursor_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_cursor_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

BEGIN;
DECLARE exttab_cur1 no scroll cursor FOR
(SELECT e1.i, e2.j from exttab_cursor_1 e1 INNER JOIN exttab_cursor_1 e2 ON e1.i = e2.i
ORDER BY e1.i);
-- Should not fail
FETCH exttab_cur1;
 i |    j     
---+----------
 1 | 1_number
(1 row)

FETCH exttab_cur1;
 i |    j     
---+----------
 2 | 2_number
(1 row)

FETCH exttab_cur1;
 i |    j     
---+----------
 4 | 4_number
(1 row)

FETCH exttab_cur1;
 i |    j     
---+----------
 6 | 6_number
(1 row)

FETCH exttab_cur1;
 i |    j     
---+----------
 7 | 7_number
(1 row)

FETCH exttab_cur1;
 i |    j     
---+----------
 8 | 8_number
(1 row)

FETCH exttab_cur1;
 i |    j     
---+----------
 9 | 9_number
(1 row)

FETCH exttab_cur1;
 i  |     j     
----+-----------
 10 | 10_number
(1 row)

FETCH exttab_cur1;
 i | j 
---+---
(0 rows)

FETCH exttab_cur1;
 i | j 
---+---
(0 rows)

COMMIT;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
-- This should have errors populated already
SELECT count(*) > 0 FROM gp_read_error_log('exttab_cursor_1');
 ?column? 
----------
 t
(1 row)

-- Check permissions with gp_truncate_error_log and gp_read_error_log
-- does not reach reject limit
CREATE EXTERNAL TABLE exttab_permissions_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
-- reaches reject limit
CREATE EXTERNAL TABLE exttab_permissions_2( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
-- generate some error logs
SELECT COUNT(*) FROM exttab_permissions_1;
NOTICE:  Found 2 data formatting errors (2 or more input rows). Rejected related input data.
 count 
-------
     8
(1 row)

SELECT COUNT(*) FROM exttab_permissions_2;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice1 @hostname@:40000 pid=51006)
DETAIL:  External table exttab_permissions_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
-- Only superuser can do gp_truncate_error_log('*.*')
DROP ROLE IF EXISTS exttab_non_superuser;
CREATE ROLE exttab_non_superuser WITH NOSUPERUSER LOGIN CREATEDB;
NOTICE:  resource queue required -- using default resource queue "pg_default"
SET ROLE exttab_non_superuser;
SELECT COUNT(*) FROM gp_read_error_log('exttab_permissions_1');
ERROR:  permission denied for relation exttab_permissions_1  (seg2 slice1 @hostname@:40002 pid=50448)
SELECT COUNT(*) FROM gp_read_error_log('exttab_permissions_2');
ERROR:  permission denied for relation exttab_permissions_2  (seg1 slice1 @hostname@:40001 pid=50437)
SELECT gp_truncate_error_log('exttab_permissions_1');
ERROR:  permission denied for relation exttab_permissions_1
SELECT gp_truncate_error_log('exttab_permissions_2');
ERROR:  permission denied for relation exttab_permissions_2
SELECT gp_truncate_error_log('*');
ERROR:  must be owner of database regression
SELECT gp_truncate_error_log('*.*');
ERROR:  must be superuser to delete all error log files
RESET ROLE;
DROP ROLE IF EXISTS exttab_superuser;
CREATE ROLE exttab_superuser WITH SUPERUSER LOGIN;
SET ROLE exttab_superuser;
SELECT COUNT(*) FROM gp_read_error_log('exttab_permissions_1');
 count 
-------
     2
(1 row)

SELECT COUNT(*) FROM gp_read_error_log('exttab_permissions_2');
 count 
-------
     1
(1 row)

SELECT gp_truncate_error_log('*');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('*.*');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_permissions_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_permissions_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

RESET ROLE;
SELECT * FROM gp_read_error_log('exttab_permissions_1');
 cmdtime | relname | filename | linenum | bytenum | errmsg | rawdata | rawbytes 
---------+---------+----------+---------+---------+--------+---------+----------
(0 rows)

SELECT * FROM gp_read_error_log('exttab_permissions_2');
 cmdtime | relname | filename | linenum | bytenum | errmsg | rawdata | rawbytes 
---------+---------+----------+---------+---------+--------+---------+----------
(0 rows)

-- Only database owner can do gp_truncate_error_log('*')
DROP DATABASE IF EXISTS exttab_db;
DROP ROLE IF EXISTS exttab_user1;
DROP ROLE IF EXISTS exttab_user2;
CREATE ROLE exttab_user1 WITH NOSUPERUSER LOGIN;
NOTICE:  resource queue required -- using default resource queue "pg_default"
CREATE ROLE exttab_user2 WITH NOSUPERUSER LOGIN;
NOTICE:  resource queue required -- using default resource queue "pg_default"
CREATE DATABASE exttab_db WITH OWNER=exttab_user1;
\c exttab_db
-- generate some error logs in this db
NOTICE:  table "exttab_permissions_1" does not exist, skipping
CREATE EXTERNAL TABLE exttab_permissions_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
SELECT COUNT(*) FROM exttab_permissions_1 e1, exttab_permissions_1 e2;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 count 
-------
    64
(1 row)

SELECT COUNT(*) FROM gp_read_error_log('exttab_permissions_1');
 count 
-------
     4
(1 row)

SET ROLE exttab_user2;
SELECT COUNT(*) FROM gp_read_error_log('exttab_permissions_1');
ERROR:  permission denied for relation exttab_permissions_1  (seg0 slice1 @hostname@:40000 pid=51060)
SELECT gp_truncate_error_log('*');
ERROR:  must be owner of database exttab_db
SELECT gp_truncate_error_log('*.*');
ERROR:  must be superuser to delete all error log files
SELECT gp_truncate_error_log('exttab_permissions_1');
ERROR:  permission denied for relation exttab_permissions_1
SET ROLE exttab_user1;
-- Database owner can still not perform read / truncate on specific tables. This follows the same mechanism as TRUNCATE table.
SELECT COUNT(*) FROM gp_read_error_log('exttab_permissions_1');
ERROR:  permission denied for relation exttab_permissions_1  (seg1 slice1 @hostname@:40001 pid=51061)
SELECT gp_truncate_error_log('exttab_permissions_1');
ERROR:  permission denied for relation exttab_permissions_1
SELECT gp_truncate_error_log('*');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

-- should fail
SELECT gp_truncate_error_log('*.*');
ERROR:  must be superuser to delete all error log files
RESET ROLE;
SELECT * FROM gp_read_error_log('exttab_permissions_1');
 cmdtime | relname | filename | linenum | bytenum | errmsg | rawdata | rawbytes 
---------+---------+----------+---------+---------+--------+---------+----------
(0 rows)

\c regression
DROP ROLE IF EXISTS errlog_exttab_user3;
DROP ROLE IF EXISTS errlog_exttab_user4;
CREATE ROLE errlog_exttab_user3 WITH NOSUPERUSER LOGIN;
NOTICE:  resource queue required -- using default resource queue "pg_default"
CREATE ROLE errlog_exttab_user4 WITH NOSUPERUSER LOGIN;
NOTICE:  resource queue required -- using default resource queue "pg_default"
-- generate some error logs in this db
CREATE EXTERNAL TABLE exttab_permissions_3( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10; 
SELECT COUNT(*) FROM exttab_permissions_3 e1, exttab_permissions_3 e2;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 count 
-------
    64
(1 row)

SELECT COUNT(*) FROM gp_read_error_log('exttab_permissions_3');
 count 
-------
     4
(1 row)

ALTER EXTERNAL TABLE exttab_permissions_3 OWNER TO errlog_exttab_user3;
-- This should fail with non table owner
SET ROLE errlog_exttab_user4;
SELECT COUNT(*) FROM gp_read_error_log('exttab_permissions_3');
ERROR:  permission denied for relation exttab_permissions_3  (seg0 slice1 @hostname@:40000 pid=51087)
SELECT gp_truncate_error_log('exttab_permissions_3');
ERROR:  permission denied for relation exttab_permissions_3
-- should go through fine with table owner
SET ROLE errlog_exttab_user3;
SELECT gp_truncate_error_log('exttab_permissions_3');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

RESET ROLE;
SELECT * FROM gp_read_error_log('exttab_permissions_3');
 cmdtime | relname | filename | linenum | bytenum | errmsg | rawdata | rawbytes 
---------+---------+----------+---------+---------+--------+---------+----------
(0 rows)

-- Grant TRUNCATE permission on table to a non table owner and make sure he is able to do gp_truncate_error_log
GRANT TRUNCATE on exttab_permissions_3 to errlog_exttab_user4;
SELECT COUNT(*) FROM exttab_permissions_3 e1, exttab_permissions_3 e2;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 count 
-------
    64
(1 row)

SELECT COUNT(*) FROM gp_read_error_log('exttab_permissions_3');
 count 
-------
     4
(1 row)

SET ROLE errlog_exttab_user4;
SELECT gp_truncate_error_log('exttab_permissions_3');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

RESET ROLE;
SELECT * FROM gp_read_error_log('exttab_permissions_3');
 cmdtime | relname | filename | linenum | bytenum | errmsg | rawdata | rawbytes 
---------+---------+----------+---------+---------+--------+---------+----------
(0 rows)

-- Subqueries reaching segment reject limit
-- does not reach reject limit
CREATE EXTERNAL TABLE exttab_subq_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
-- reaches reject limit, use the same err table
CREATE EXTERNAL TABLE exttab_subq_2( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
SELECT sum(distinct e1.i), sum(distinct e2.i), e1.j FROM
(SELECT i, j FROM exttab_subq_1 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_subq_2 WHERE i < 10) e2
group by e1.j;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice2 @hostname@:40000 pid=66875)
DETAIL:  External table exttab_subq_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
SELECT COUNT(*) > 0 FROM
(
SELECT * FROM gp_read_error_log('exttab_subq_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_subq_2')
) FOO;
 ?column? 
----------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_subq_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_subq_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT sum(distinct e1.i), sum(distinct e2.i), e1.j FROM
(SELECT i, j FROM exttab_subq_1 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_subq_1 WHERE i < 10) e2
group by e1.j
HAVING sum(distinct e1.i) > (SELECT max(i) FROM exttab_subq_2);
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice4 @hostname@:40000 pid=66866)
DETAIL:  External table exttab_subq_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
SELECT COUNT(*) > 0 FROM
(
SELECT * FROM gp_read_error_log('exttab_subq_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_subq_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- Subqueries without reaching segment reject limit
SELECT gp_truncate_error_log('exttab_subq_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_subq_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT sum(distinct e1.i), sum(distinct e2.i), e1.j FROM
(SELECT i, j FROM exttab_subq_1 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_subq_1 WHERE i < 10) e2
group by e1.j order by 3,2,1;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 sum | sum |    j     
-----+-----+----------
   1 |  37 | 1_number
   2 |  37 | 2_number
   4 |  37 | 4_number
(3 rows)

SELECT COUNT(*) > 0 FROM gp_read_error_log('exttab_subq_1');
 ?column? 
----------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_subq_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_subq_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT sum(distinct e1.i), sum(distinct e2.i), e1.j FROM
(SELECT i, j FROM exttab_subq_1 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_subq_1 WHERE i < 10) e2
group by e1.j
HAVING sum(distinct e1.i) > (SELECT max(i) FROM exttab_subq_1);
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 sum | sum | j 
-----+-----+---
(0 rows)

SELECT COUNT(*) > 0 FROM gp_read_error_log('exttab_subq_1');
 ?column? 
----------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_subq_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_subq_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT e1.i , e1.j FROM
exttab_subq_1 e1, exttab_subq_1 e2
WHERE e1.j = e2.j and 
e1.i + 1 IN ( SELECT i from exttab_subq_1 WHERE i <= e1.i);
NOTICE:  Found 6 data formatting errors (6 or more input rows). Rejected related input data.
 i | j 
---+---
(0 rows)

SELECT COUNT(*) > 0 FROM gp_read_error_log('exttab_subq_1');
 ?column? 
----------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_subq_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_subq_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT ( SELECT i FROM exttab_subq_2 WHERE i <= e1.i) as i, e1.j
FROM exttab_subq_2 e1, exttab_subq_1 e2
WHERE e1.i = e2.i;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice2 @hostname@:40000 pid=49348)
DETAIL:  External table exttab_subq_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
SELECT COUNT(*) > 0 FROM gp_read_error_log('exttab_subq_1');
 ?column? 
----------
 t
(1 row)

-- CSQ
SELECT gp_truncate_error_log('exttab_subq_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_subq_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT e1.i , e1.j FROM
exttab_subq_1 e1, exttab_subq_1 e2
WHERE e1.j = e2.j and 
e1.i + 1 IN ( SELECT i from exttab_subq_2 WHERE i <= e1.i);
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice1 @hostname@:40000 pid=66875)
DETAIL:  External table exttab_subq_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
SELECT COUNT(*) > 0 FROM
(
SELECT * FROM gp_read_error_log('exttab_subq_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_subq_2')
) FOO;
 ?column? 
----------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_subq_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_subq_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT ( SELECT i FROM exttab_subq_2 WHERE i <= e1.i) as i, e1.j
FROM exttab_subq_2 e1, exttab_subq_1 e2
WHERE e1.i = e2.i;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice2 @hostname@:40000 pid=66866)
DETAIL:  External table exttab_subq_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
SELECT COUNT(*) > 0 FROM
(
SELECT * FROM gp_read_error_log('exttab_subq_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_subq_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- TRUNCATE / delete / write to error logs within subtransactions
-- does not reach reject limit
CREATE EXTERNAL TABLE exttab_subtxs_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
-- reaches reject limit, use the same err table
CREATE EXTERNAL TABLE exttab_subtxs_2( i int, j text ) 
LOCATION ('file://@hostname@:@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
-- Populate error logs before transaction
SELECT e1.i, e2.j FROM
(SELECT i, j FROM exttab_subtxs_1 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_subtxs_1 WHERE i < 10) e2
WHERE e1.i = e2.i;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 i |    j     
---+----------
 1 | 1_number
 2 | 2_number
 4 | 4_number
(3 rows)

SELECT COUNT(*)
FROM (
SELECT * FROM gp_read_error_log('exttab_subtxs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_subtxs_2')
) FOO;
 count 
-------
     4
(1 row)

BEGIN;
savepoint s1;
SELECT gp_truncate_error_log('exttab_subtxs_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_subtxs_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT e1.i, e2.j FROM
(SELECT i, j FROM exttab_subtxs_1 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_subtxs_1 WHERE i < 10) e2
WHERE e1.i = e2.i;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 i |    j     
---+----------
 1 | 1_number
 2 | 2_number
 4 | 4_number
(3 rows)

-- should have written rows into error log
SELECT count(*) FROM
(
SELECT * FROM gp_read_error_log('exttab_subtxs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_subtxs_2')
) FOO;
 count 
-------
     4
(1 row)

savepoint s2;
SELECT e1.i, e2.j FROM
(SELECT i, j FROM exttab_subtxs_1 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_subtxs_1 WHERE i < 10) e2
WHERE e1.i = e2.i;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 i |    j     
---+----------
 1 | 1_number
 2 | 2_number
 4 | 4_number
(3 rows)

savepoint s3;
SELECT e1.i, e2.j FROM
(SELECT i, j FROM exttab_subtxs_1 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_subtxs_1 WHERE i < 10) e2
WHERE e1.i = e2.i;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 i |    j     
---+----------
 1 | 1_number
 2 | 2_number
 4 | 4_number
(3 rows)

ROLLBACK TO s2;
-- rollback should not rollback the error rows written from within the transaction
SELECT count(*) FROM
(
SELECT * FROM gp_read_error_log('exttab_subtxs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_subtxs_2')
) FOO;
 count 
-------
    12
(1 row)

-- Make the tx fail, segment reject limit reaches here
SELECT e1.i, e2.j FROM
(SELECT i, j FROM exttab_subtxs_2 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_subtxs_2 WHERE i < 10) e2
WHERE e1.i = e2.i;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice1 @hostname@:40000 pid=70905)
DETAIL:  External table exttab_subtxs_2, line 7 of file://@hostname@:@abs_srcdir@/data/exttab_more_errors.data: "error_1"
COMMIT;
-- Error logs should not have been rolled back. 
-- Check that number of errors is greater than 12 instead of checking for
-- actual number of errors, since the transaction might get aborted even before
-- rows are scanned on other segments if one of the segments hits the segment
-- reject limit. The 12 errors are from previous scans of the external table.
SELECT count(*) > 12 FROM
(
SELECT * FROM gp_read_error_log('exttab_subtxs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_subtxs_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- TRUNCATE error logs within tx , abort transaction
-- does not reach reject limit
CREATE EXTERNAL TABLE exttab_txs_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
-- reaches reject limit, use the same err table
CREATE EXTERNAL TABLE exttab_txs_2( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
-- Populate error log before transaction
SELECT e1.i, e2.j FROM
(SELECT i, j FROM exttab_txs_1 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_txs_1 WHERE i < 10) e2
WHERE e1.i = e2.i;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 i |    j     
---+----------
 1 | 1_number
 2 | 2_number
 4 | 4_number
(3 rows)

SELECT count(*) FROM
(
SELECT * FROM gp_read_error_log('exttab_txs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_txs_2')
) FOO;
 count 
-------
     4
(1 row)

BEGIN;
SELECT gp_truncate_error_log('exttab_txs_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_txs_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT e1.i, e2.j FROM
(SELECT i, j FROM exttab_txs_1 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_txs_1 WHERE i < 10) e2
WHERE e1.i = e2.i;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 i |    j     
---+----------
 1 | 1_number
 2 | 2_number
 4 | 4_number
(3 rows)

ABORT;
-- Check that number of errors is greater than zero instead of checking the
-- actual number of errors since the transaction might get aborted even before
-- rows are scanned on other segments if one of the segments hits the segment
-- reject limit.
SELECT count(*) > 0 FROM
(
SELECT * FROM gp_read_error_log('exttab_txs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_txs_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- TRUNCATE error logs within txs , with segment reject limit reached
-- Populate error log before transaction
SELECT e1.i, e2.j FROM
(SELECT i, j FROM exttab_txs_1 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_txs_1 WHERE i < 10) e2
WHERE e1.i = e2.i;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 i |    j     
---+----------
 1 | 1_number
 2 | 2_number
 4 | 4_number
(3 rows)

SELECT count(*) FROM
(
SELECT * FROM gp_read_error_log('exttab_txs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_txs_2')
) FOO;
 count 
-------
     8
(1 row)

BEGIN;
SELECT gp_truncate_error_log('exttab_txs_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_txs_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

-- This should abort the transaction
SELECT e1.i, e2.j FROM
(SELECT i, j FROM exttab_txs_1 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_txs_2 WHERE i < 10) e2
WHERE e1.i = e2.i;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice2 @hostname@:40000 pid=76719)
DETAIL:  External table exttab_txs_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
COMMIT;
-- Additional error rows should have been inserted into the error logs even if the tx is aborted.
-- Truncate of error logs should not be rolled back even if the transaction is aborted. All operation on error logs are persisted. 
-- Check that number of errors is greater than zero instead of checking for
-- actual number of errors, since the transaction might get aborted even before
-- rows are scanned on other segments if one of the segments hits the segment
-- reject limit.
SELECT count(*) > 0 FROM
(
SELECT * FROM gp_read_error_log('exttab_txs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_txs_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- Creating external table with error log within txs with segment reject limits reached
SELECT gp_truncate_error_log('exttab_txs_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_txs_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

DROP EXTERNAL TABLE IF EXISTS exttab_txs_3;
NOTICE:  table "exttab_txs_3" does not exist, skipping
DROP EXTERNAL TABLE IF EXISTS exttab_txs_4;
NOTICE:  table "exttab_txs_4" does not exist, skipping
BEGIN;
-- create an external table that will reach segment reject limit
-- reaches reject limit
CREATE EXTERNAL TABLE exttab_txs_3( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
-- new error log, within segment reject limit
CREATE EXTERNAL TABLE exttab_txs_4( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
SELECT e1.i, e2.j FROM
(SELECT i, j FROM exttab_txs_4 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_txs_4 WHERE i < 10) e2
WHERE e1.i = e2.i order by e1.i;
NOTICE:  Found 4 data formatting errors (4 or more input rows). Rejected related input data.
 i |    j     
---+----------
 1 | 1_number
 2 | 2_number
 4 | 4_number
(3 rows)

-- should be populated correctly
SELECT count(*) FROM gp_read_error_log('exttab_txs_4');
 count 
-------
     4
(1 row)

-- should error out and abort the transaction
SELECT e1.i, e2.j FROM
(SELECT i, j FROM exttab_txs_3 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_txs_4 WHERE i < 10) e2
WHERE e1.i = e2.i order by e1.i;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice1 @hostname@:40000 pid=76727)
DETAIL:  External table exttab_txs_3, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
COMMIT;
-- Error logs should not exist for these tables that would have been rolled back 
SELECT count(*) FROM gp_read_error_log('exttab_txs_3');
 count 
-------
     0
(1 row)

SELECT count(*) FROM gp_read_error_log('exttab_txs_4');
 count 
-------
     0
(1 row)

-- external tables created within aborted transactions should not exist
SELECT count(*) FROM exttab_txs_3;
ERROR:  relation "exttab_txs_3" does not exist
LINE 1: SELECT count(*) FROM exttab_txs_3;
                             ^
SELECT count(*) FROM exttab_txs_4;
ERROR:  relation "exttab_txs_4" does not exist
LINE 1: SELECT count(*) FROM exttab_txs_4;
                             ^
-- UDFS with segment reject limit reached
-- does not reach reject limit
CREATE EXTERNAL TABLE exttab_udfs_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
-- reaches reject limit, use the same err table
CREATE EXTERNAL TABLE exttab_udfs_2( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
CREATE OR REPLACE FUNCTION exttab_udfs_func1 ()
RETURNS boolean
AS $$
BEGIN
  EXECUTE 'SELECT sum(distinct e1.i) as sum_i, sum(distinct e2.i) as sum_j, e1.j as j FROM
	   (SELECT i, j FROM exttab_udfs_1 WHERE i < 5 ) e1,
	   (SELECT i, j FROM exttab_udfs_2 WHERE i < 10) e2
	   group by e1.j';
  RETURN 1;
END;
$$
LANGUAGE plpgsql volatile;
-- Should fail
SELECT * FROM exttab_udfs_func1();
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice2 @hostname@:40000 pid=77376)
DETAIL:  External table exttab_udfs_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
CONTEXT:  SQL statement "SELECT sum(distinct e1.i) as sum_i, sum(distinct e2.i) as sum_j, e1.j as j FROM
	   (SELECT i, j FROM exttab_udfs_1 WHERE i < 5 ) e1,
	   (SELECT i, j FROM exttab_udfs_2 WHERE i < 10) e2
	   group by e1.j"
PL/pgSQL function "exttab_udfs_func1" line 2 at EXECUTE statement
-- Should be populated
SELECT COUNT(*) > 0 FROM 
(
SELECT * FROM gp_read_error_log('exttab_udfs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_udfs_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- INSERT INTO from a udf
DROP TABLE IF EXISTS exttab_udfs_insert_1;
NOTICE:  table "exttab_udfs_insert_1" does not exist, skipping
CREATE TABLE exttab_udfs_insert_1(a boolean);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'a' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
SELECT gp_truncate_error_log('exttab_udfs_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_udfs_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

-- Should fail
INSERT INTO exttab_udfs_insert_1 SELECT * FROM exttab_udfs_func1();
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice2 @hostname@:40000 pid=77376)
DETAIL:  External table exttab_udfs_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
CONTEXT:  SQL statement "SELECT sum(distinct e1.i) as sum_i, sum(distinct e2.i) as sum_j, e1.j as j FROM
	   (SELECT i, j FROM exttab_udfs_1 WHERE i < 5 ) e1,
	   (SELECT i, j FROM exttab_udfs_2 WHERE i < 10) e2
	   group by e1.j"
PL/pgSQL function "exttab_udfs_func1" line 2 at EXECUTE statement
SELECT * FROM exttab_udfs_insert_1;
 a 
---
(0 rows)

-- Error table should be populated correctly
SELECT COUNT(*) > 0 FROM 
(
SELECT * FROM gp_read_error_log('exttab_udfs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_udfs_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- UDFs with INSERT INTO with segment reject limit reached
DROP TABLE IF EXISTS exttab_udfs_insert_2;
NOTICE:  table "exttab_udfs_insert_2" does not exist, skipping
CREATE TABLE exttab_udfs_insert_2 (LIKE exttab_udfs_1);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
CREATE OR REPLACE FUNCTION exttab_udfs_func2 ()
RETURNS boolean
AS $$
DECLARE
 r RECORD;
 cnt integer;
 result boolean;
BEGIN
  SELECT INTO result gp_truncate_error_log('exttab_udfs_1');
  SELECT INTO result gp_truncate_error_log('exttab_udfs_2');
  INSERT INTO exttab_udfs_insert_2
  SELECT i, j from exttab_udfs_1;
  cnt := 0;
  FOR r in SELECT * FROM gp_read_error_log('exttab_udfs_1') LOOP
      -- just looping through the error log
      cnt := cnt + 1;
  END LOOP;
  IF cnt <= 0 THEN
      RAISE EXCEPTION 'Error log should not be empty';
  END IF;
  SELECT count(*) INTO cnt FROM exttab_udfs_insert_2;
  -- should be 8
  IF cnt <> 8 THEN
      RAISE EXCEPTION 'Unexpected number of rows inserted';
  END IF;
  -- Now make insert into fail
  INSERT INTO exttab_udfs_insert_2
  SELECT i, j from exttab_udfs_2;
  -- Should not reach here
  cnt := 0;
  FOR r in SELECT * FROM gp_read_error_log('exttab_udfs_2') LOOP
      -- just looping through the error log
      cnt := cnt + 1;
  END LOOP;
  IF cnt <= 0 THEN
      RAISE EXCEPTION 'Error table should not be empty';
  END IF;
  RETURN 1;
END;
$$
LANGUAGE plpgsql volatile;
SELECT gp_truncate_error_log('exttab_udfs_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_udfs_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

-- All this should fail, error logs should be populated even if the UDF gets aborted as we persist error rows written within aborted txs.
SELECT * FROM exttab_udfs_func2();
NOTICE:  Found 2 data formatting errors (2 or more input rows). Rejected related input data.
CONTEXT:  SQL statement "INSERT INTO exttab_udfs_insert_2 SELECT i, j from exttab_udfs_1"
PL/pgSQL function "exttab_udfs_func2" line 8 at SQL statement
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 @hostname@:40000 pid=63695)
DETAIL:  External table exttab_udfs_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
CONTEXT:  SQL statement "INSERT INTO exttab_udfs_insert_2 SELECT i, j from exttab_udfs_2"
PL/pgSQL function "exttab_udfs_func2" line 24 at SQL statement
SELECT COUNT(*) > 0 FROM 
(
SELECT * FROM gp_read_error_log('exttab_udfs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_udfs_2')
) FOO;
 ?column? 
----------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_udfs_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_udfs_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT exttab_udfs_func2();
NOTICE:  Found 2 data formatting errors (2 or more input rows). Rejected related input data.
CONTEXT:  SQL statement "INSERT INTO exttab_udfs_insert_2 SELECT i, j from exttab_udfs_1"
PL/pgSQL function "exttab_udfs_func2" line 8 at SQL statement
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 @hostname@:40000 pid=63695)
DETAIL:  External table exttab_udfs_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
CONTEXT:  SQL statement "INSERT INTO exttab_udfs_insert_2 SELECT i, j from exttab_udfs_2"
PL/pgSQL function "exttab_udfs_func2" line 24 at SQL statement
SELECT COUNT(*) > 0 FROM 
(
SELECT * FROM gp_read_error_log('exttab_udfs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_udfs_2')
) FOO;
 ?column? 
----------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_udfs_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_udfs_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

INSERT INTO exttab_udfs_insert_1 SELECT * FROM exttab_udfs_func2();
NOTICE:  Found 2 data formatting errors (2 or more input rows). Rejected related input data.
CONTEXT:  SQL statement "INSERT INTO exttab_udfs_insert_2 SELECT i, j from exttab_udfs_1"
PL/pgSQL function "exttab_udfs_func2" line 8 at SQL statement
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 @hostname@:40000 pid=63695)
DETAIL:  External table exttab_udfs_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
CONTEXT:  SQL statement "INSERT INTO exttab_udfs_insert_2 SELECT i, j from exttab_udfs_2"
PL/pgSQL function "exttab_udfs_func2" line 24 at SQL statement
SELECT COUNT(*) > 0 FROM 
(
SELECT * FROM gp_read_error_log('exttab_udfs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_udfs_2')
) FOO;
 ?column? 
----------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_udfs_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_udfs_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

CREATE TABLE exttab_udfs_ctas_2 AS SELECT * FROM exttab_udfs_func2();
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'exttab_udfs_func2' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
NOTICE:  Found 2 data formatting errors (2 or more input rows). Rejected related input data.
CONTEXT:  SQL statement "INSERT INTO exttab_udfs_insert_2 SELECT i, j from exttab_udfs_1"
PL/pgSQL function "exttab_udfs_func2" line 8 at SQL statement
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 @hostname@:40000 pid=63695)
DETAIL:  External table exttab_udfs_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
CONTEXT:  SQL statement "INSERT INTO exttab_udfs_insert_2 SELECT i, j from exttab_udfs_2"
PL/pgSQL function "exttab_udfs_func2" line 24 at SQL statement
SELECT COUNT(*) > 0 FROM 
(
SELECT * FROM gp_read_error_log('exttab_udfs_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_udfs_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- No rows should be inserted into exttab_udfs_insert_2
SELECT * FROM exttab_udfs_insert_2;
 i | j 
---+---
(0 rows)

-- Scans in union queries with seg reject limit reached
-- does not reach reject limit
DROP EXTERNAL TABLE IF EXISTS exttab_union_1;
DROP EXTERNAL TABLE IF EXISTS exttab_union_2;
CREATE EXTERNAL TABLE exttab_union_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
-- reaches reject limit
CREATE EXTERNAL TABLE exttab_union_2( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
-- Should error out as exttab_union_2 would reach it's reject limit
SELECT * FROM
(
SELECT * FROM exttab_union_1
UNION
SELECT * FROM exttab_union_2
) FOO
order by FOO.i;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice1 @hostname@:40000 pid=78596)
DETAIL:  External table exttab_union_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
-- Error table count
select count(*) > 0 from
(
SELECT * FROM gp_read_error_log('exttab_union_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_union_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- Insert into another table, with and without segment reject limits being reached
DROP TABLE IF EXISTS exttab_union_insert_1;
NOTICE:  table "exttab_union_insert_1" does not exist, skipping
CREATE TABLE exttab_union_insert_1 (LIKE exttab_union_1);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause, defaulting to distribution columns from LIKE table
SELECT gp_truncate_error_log('exttab_union_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_union_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

insert into exttab_union_insert_1
SELECT e1.i, e2.j from exttab_union_2 e1 INNER JOIN exttab_union_2 e2 ON e1.i = e2.i
UNION ALL
SELECT e1.i, e2.j from exttab_union_2 e1 INNER JOIN exttab_union_2 e2 ON e1.i = e2.i;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice4 @hostname@:40000 pid=78649)
DETAIL:  External table exttab_union_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
-- should return 0 rows
SELECT * from exttab_union_insert_1;
 i | j 
---+---
(0 rows)

-- Error table count, should have more than 0 rows, the total number is non-deterministic
select count(*) > 0 from 
(
SELECT * FROM gp_read_error_log('exttab_union_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_union_2')
) FOO;
 ?column? 
----------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_union_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_union_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

-- should not error out as exttab_union_1 will not reach segment reject limit
insert into exttab_union_insert_1
SELECT e1.i, e2.j from exttab_union_1 e1 INNER JOIN exttab_union_1 e2 ON e1.i = e2.i
UNION
SELECT e1.i, e2.j from exttab_union_1 e1 INNER JOIN exttab_union_1 e2 ON e1.i = e2.i;
NOTICE:  Found 8 data formatting errors (8 or more input rows). Rejected related input data.
-- should return the right result
SELECT * from exttab_union_insert_1 order by i;
 i  |     j     
----+-----------
  1 | 1_number
  2 | 2_number
  4 | 4_number
  6 | 6_number
  7 | 7_number
  8 | 8_number
  9 | 9_number
 10 | 10_number
(8 rows)

-- Error table count
select count(*) > 0 FROM gp_read_error_log('exttab_union_1');
 ?column? 
----------
 t
(1 row)

-- Views reaching segment reject limit
DROP EXTERNAL TABLE IF EXISTS exttab_views_1 CASCADE;
NOTICE:  table "exttab_views_1" does not exist, skipping
DROP EXTERNAL TABLE IF EXISTS exttab_views_2 CASCADE;
NOTICE:  table "exttab_views_2" does not exist, skipping
-- does not reach reject limit
CREATE EXTERNAL TABLE exttab_views_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
-- reaches reject limit, use the same err table
CREATE EXTERNAL TABLE exttab_views_2( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
DROP VIEW IF EXISTS exttab_views_3;
NOTICE:  view "exttab_views_3" does not exist, skipping
CREATE VIEW exttab_views_3 as
SELECT sum(distinct e1.i) as sum_i, sum(distinct e2.i) as sum_j, e1.j as j FROM
(SELECT i, j FROM exttab_views_1 WHERE i < 5 ) e1,
(SELECT i, j FROM exttab_views_2 WHERE i < 10) e2
group by e1.j;
SELECT gp_truncate_error_log('exttab_views_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_views_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

-- This should error out
SELECT * FROM exttab_views_3;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice2 @hostname@:40000 pid=79499)
DETAIL:  External table exttab_views_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
-- Error table should be populated
SELECT count(*) > 0 FROM
(
SELECT * FROM gp_read_error_log('exttab_views_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_views_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- INSERT INTO FROM a view
DROP TABLE IF EXISTS exttab_views_insert_1;
NOTICE:  table "exttab_views_insert_1" does not exist, skipping
CREATE TABLE exttab_views_insert_1 (i int, j int, k text);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
SELECT gp_truncate_error_log('exttab_views_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_views_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

-- Should fail
INSERT INTO exttab_views_insert_1 SELECT * FROM exttab_views_3;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice2 @hostname@:40000 pid=79496)
DETAIL:  External table exttab_views_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
-- should not have any rows
SELECT * FROM exttab_views_insert_1; 
 i | j | k 
---+---+---
(0 rows)

-- Error table should be populated
SELECT count(*) > 0 FROM
(
SELECT * FROM gp_read_error_log('exttab_views_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_views_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- CTAS from a view with segment reject limit reached
DROP TABLE IF EXISTS exttab_views_ctas_1;
NOTICE:  table "exttab_views_ctas_1" does not exist, skipping
SELECT gp_truncate_error_log('exttab_views_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_views_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

-- Should fail 
CREATE TABLE exttab_views_ctas_1 AS SELECT * FROM exttab_views_3 where j::integer < 100;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'j' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice2 @hostname@:40000 pid=79505)
DETAIL:  External table exttab_views_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
SELECT * FROM exttab_views_ctas_1;
ERROR:  relation "exttab_views_ctas_1" does not exist
LINE 1: SELECT * FROM exttab_views_ctas_1;
                      ^
-- Error table should be populated
SELECT count(*) > 0 FROM
(
SELECT * FROM gp_read_error_log('exttab_views_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_views_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- CTAS FROM view with segment reject limits reached
DROP TABLE IF EXISTS exttab_views_ctas_1;
NOTICE:  table "exttab_views_ctas_1" does not exist, skipping
SELECT gp_truncate_error_log('exttab_views_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_views_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

-- Should fail here 
CREATE TABLE exttab_views_ctas_1 AS SELECT * FROM exttab_views_3;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'j' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice2 @hostname@:40000 pid=79499)
DETAIL:  External table exttab_views_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
-- Relation should not exist
SELECT * FROM exttab_views_ctas_1;
ERROR:  relation "exttab_views_ctas_1" does not exist
LINE 1: SELECT * FROM exttab_views_ctas_1;
                      ^
-- Error table should be populated
SELECT count(*) > 0 FROM
(
SELECT * FROM gp_read_error_log('exttab_views_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_views_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- Scans in window queries with and without seg reject limit reached
DROP EXTERNAL TABLE IF EXISTS exttab_windows_1;
NOTICE:  table "exttab_windows_1" does not exist, skipping
DROP EXTERNAL TABLE IF EXISTS exttab_windows_2;
NOTICE:  table "exttab_windows_2" does not exist, skipping
-- does not reach reject limit
CREATE EXTERNAL TABLE exttab_windows_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
-- reaches reject limit
CREATE EXTERNAL TABLE exttab_windows_2( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
-- without reaching segment reject limit
with cte1 as(
 select t1.i as i,
        sum(t2.i) sum_i,
        avg(sum(t2.i)) over
          (partition by t2.j)
          avg_j,
        rank() over
          (partition by t2.j order by t1.j) rnk_j
 from exttab_windows_1 t1, exttab_windows_1 t2
 where t1.i = t2.i
 group by t1.i,t2.j,t1.j
),
cte2 as
(
 select t1.i as i,
        sum(t2.i) sum_i,
        avg(sum(t2.i)) over
          (partition by t2.j)
          avg_j,
        rank() over
          (partition by t2.j order by t1.j) rnk_j
 from exttab_windows_1 t1, exttab_windows_1 t2
 where t1.i = t2.i
 group by t1.i, t2.j, t1.j
)
SELECT * FROM cte1 c1, cte2 c2
WHERE c1.i = c2.i
ORDER BY c1.i
limit 5;
NOTICE:  Found 8 data formatting errors (8 or more input rows). Rejected related input data.
 i | sum_i | avg_j | rnk_j | i | sum_i | avg_j | rnk_j 
---+-------+-------+-------+---+-------+-------+-------
 1 |     1 |     1 |     1 | 1 |     1 |     1 |     1
 2 |     2 |     2 |     1 | 2 |     2 |     2 |     1
 4 |     4 |     4 |     1 | 4 |     4 |     4 |     1
 6 |     6 |     6 |     1 | 6 |     6 |     6 |     1
 7 |     7 |     7 |     1 | 7 |     7 |     7 |     1
(5 rows)

SELECT relname,linenum,errmsg,rawdata FROM gp_read_error_log('exttab_windows_1') ORDER BY linenum LIMIT 2;
     relname      | linenum |           errmsg            | rawdata 
------------------+---------+-----------------------------+---------
 exttab_windows_1 |       3 | missing data for column "j" | error_0
 exttab_windows_1 |       3 | missing data for column "j" | error_0
(2 rows)

-- with reaching segment reject limit
SELECT gp_truncate_error_log('exttab_windows_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_windows_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

with cte1 as(
 select t1.i as i,
        sum(t2.i) sum_i,
        avg(sum(t2.i)) over
          (partition by t2.j)
          avg_j,
        rank() over
          (partition by t2.j order by t1.j) rnk_j
 from exttab_windows_1 t1, exttab_windows_2 t2
 where t1.i = t2.i
 group by t1.i,t2.j,t1.j
),
cte2 as
(
 select t1.i as i,
        sum(t2.i) sum_i,
        avg(sum(t2.i)) over
          (partition by t2.j)
          avg_j,
        rank() over
          (partition by t2.j order by t1.j) rnk_j
 from exttab_windows_1 t1, exttab_windows_2 t2
 where t1.i = t2.i
 group by t1.i, t2.j, t1.j
)
SELECT * FROM cte1 c1, cte2 c2
WHERE c1.i = c2.i
ORDER BY c1.i
limit 5;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice6 @hostname@:40000 pid=79568)
DETAIL:  External table exttab_windows_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
SELECT COUNT(*) > 0 
FROM
(
SELECT * FROM gp_read_error_log('exttab_windows_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_windows_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- LIMIT queries without segment reject limit reached
DROP EXTERNAL TABLE IF EXISTS exttab_limit_1 cascade;
NOTICE:  table "exttab_limit_1" does not exist, skipping
DROP EXTERNAL TABLE IF EXISTS exttab_limit_2 cascade;
NOTICE:  table "exttab_limit_2" does not exist, skipping
-- does not reach reject limit
CREATE EXTERNAL TABLE exttab_limit_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
-- reaches reject limit, use the same err table
CREATE EXTERNAL TABLE exttab_limit_2( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_more_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 2;
-- Note that even though we use exttab_limit_2 here , the LIMIT 3 will not throw a segment reject limit error
with cte1 as 
(
SELECT e1.i, e2.j FROM exttab_limit_1 e1, exttab_limit_1 e2
WHERE e1.i = e2.i LIMIT 5
)
SELECT * FROM cte1, exttab_limit_2 e3 where cte1.i = e3.i ORDER BY cte1.i LIMIT 3;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice4 @hostname@:40000 pid=49348)
DETAIL:  External table exttab_limit_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
SELECT count(*) FROM gp_read_error_log('exttab_limit_1');
 count 
-------
     4
(1 row)

SELECT gp_truncate_error_log('exttab_limit_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_limit_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

-- Note that even though we use exttab_limit_2 here , the LIMIT 3 will not throw a segment reject limit error
SELECT * FROM
(
(SELECT * FROM exttab_limit_1 LIMIT 3)
UNION
(SELECT * FROM exttab_limit_1 LIMIT 3)
UNION
(SELECT * FROM exttab_limit_1 LIMIT 3)
UNION
(SELECT * FROM exttab_limit_1 LIMIT 3)
UNION
(SELECT * FROM exttab_limit_1 LIMIT 5)
UNION
(SELECT * FROM exttab_limit_2 LIMIT 3)
UNION
(SELECT * FROM exttab_limit_2 LIMIT 3)
UNION
(SELECT * FROM exttab_limit_2 LIMIT 3)
) FOO
ORDER BY i LIMIT 5;
NOTICE:  Found 6 data formatting errors (6 or more input rows). Rejected related input data.
 i |    j     
---+----------
 1 | 1_number
 2 | 2_number
 3 | 3_number
 4 | 4_number
 6 | 6_number
(5 rows)

SELECT COUNT(*) > 0 FROM gp_read_error_log('exttab_limit_1');
 ?column? 
----------
 t
(1 row)

SELECT COUNT(*) > 0 FROM gp_read_error_log('exttab_limit_2');
 ?column? 
----------
 f
(1 row)

-- LIMIT queries with segment reject limit reached
SELECT gp_truncate_error_log('exttab_limit_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_limit_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

with cte1 as 
(
SELECT e1.i, e2.j FROM exttab_limit_1 e1, exttab_limit_1 e2
WHERE e1.i = e2.i LIMIT 3
)
SELECT * FROM cte1, exttab_limit_2 e3 where cte1.i = e3.i ORDER BY cte1.i LIMIT 5;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice2 @hostname@:40000 pid=35568)
DETAIL:  External table exttab_limit_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
SELECT count(*) > 0 FROM gp_read_error_log('exttab_limit_2');
 ?column? 
----------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_limit_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_limit_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT * FROM
(
(SELECT * FROM exttab_limit_1 LIMIT 3)
UNION
(SELECT * FROM exttab_limit_1 LIMIT 3)
UNION
(SELECT * FROM exttab_limit_1 LIMIT 3)
UNION
(SELECT * FROM exttab_limit_1 LIMIT 3)
UNION
(SELECT * FROM exttab_limit_2 LIMIT 5)
UNION
(SELECT * FROM exttab_limit_2 LIMIT 5)
UNION
(SELECT * FROM exttab_limit_2 LIMIT 5)
UNION
(SELECT * FROM exttab_limit_2 LIMIT 5)
) FOO
ORDER BY i LIMIT 5;
NOTICE:  Found 8 data formatting errors (8 or more input rows). Rejected related input data.
 i |    j     
---+----------
 1 | 1_number
 2 | 2_number
 3 | 3_number
 4 | 4_number
 6 | 6_number
(5 rows)

SELECT count(*) > 0 FROM 
(
SELECT * FROM gp_read_error_log('exttab_limit_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_limit_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- This query will materialize exttab_limit_2 completely even if LIMIT is just 3 and hence will throw segment reject limit reached
SELECT gp_truncate_error_log('exttab_limit_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT gp_truncate_error_log('exttab_limit_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT * FROM exttab_limit_1 e1, exttab_limit_2 e2 where e1.i = e2.i LIMIT 3;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice2 @hostname@:40000 pid=9815)
DETAIL:  External table exttab_limit_2, line 7 of file://@hostname@@abs_srcdir@/data/exttab_more_errors.data: "error_1"
SELECT count(*) > 0 FROM 
(
SELECT * FROM gp_read_error_log('exttab_limit_1')
UNION ALL
SELECT * FROM gp_read_error_log('exttab_limit_2')
) FOO;
 ?column? 
----------
 t
(1 row)

-- gp_initial_bad_row_limit guc test. This guc allows user to set the initial
-- number of rows which can contain errors before the database stops loading
-- the data. If there is a valid row within the first 'n' rows specified by
-- this guc, the database continues to load the data. 
-- default should be 1000
SHOW gp_initial_bad_row_limit;
 gp_initial_bad_row_limit 
--------------------------
 1000
(1 row)

DROP EXTERNAL TABLE IF EXISTS exttab_first_reject_limit_1 cascade;
NOTICE:  table "exttab_first_reject_limit_1" does not exist, skipping
CREATE EXTERNAL TABLE exttab_first_reject_limit_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_first_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 20000;
-- should fail with an appropriate error message
SELECT COUNT(*) FROM exttab_first_reject_limit_1;
ERROR:  All 1000 first rows in this segment were rejected. Aborting operation regardless of REJECT LIMIT value. Last error was: missing data for column "j"  (seg0 slice1 @hostname@:40000 pid=28213)
DETAIL:  External table exttab_first_reject_limit_1, line 1000 of file://@hostname@@abs_srcdir@/data/exttab_first_errors.data: "error_0"
SELECT COUNT(*) > 0 FROM gp_read_error_log('exttab_first_reject_limit_1');
 ?column? 
----------
 t
(1 row)

-- should work now
SET gp_initial_bad_row_limit = 6000;
SELECT gp_truncate_error_log('exttab_first_reject_limit_1');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT COUNT(*) FROM exttab_first_reject_limit_1;
NOTICE:  Found 5000 data formatting errors (5000 or more input rows). Rejected related input data.
 count 
-------
  5000
(1 row)

SELECT COUNT(*) FROM gp_read_error_log('exttab_first_reject_limit_1');
 count 
-------
  5000
(1 row)

-- first segment reject limit should be checked before segment reject limit
DROP EXTERNAL TABLE IF EXISTS exttab_first_reject_limit_2;
NOTICE:  table "exttab_first_reject_limit_2" does not exist, skipping
CREATE EXTERNAL TABLE exttab_first_reject_limit_2( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_first_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 500;
-- should report an error saying first rows were rejected
SET gp_initial_bad_row_limit = 2;
SELECT COUNT(*) FROM exttab_first_reject_limit_2;
ERROR:  All 2 first rows in this segment were rejected. Aborting operation regardless of REJECT LIMIT value. Last error was: missing data for column "j"  (seg0 slice1 @hostname@:40000 pid=28213)
DETAIL:  External table exttab_first_reject_limit_2, line 2 of file://@hostname@@abs_srcdir@/data/exttab_first_errors.data: "error_0"
SELECT COUNT(*) > 0 from gp_read_error_log('exttab_first_reject_limit_2');
 ?column? 
----------
 t
(1 row)

-- should report an error saying segment reject limit reached
set gp_initial_bad_row_limit = 600;
SELECT gp_truncate_error_log('exttab_first_reject_limit_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT COUNT(*) FROM exttab_first_reject_limit_2;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice1 @hostname@:40000 pid=28213)
DETAIL:  External table exttab_first_reject_limit_2, line 500 of file://@hostname@@abs_srcdir@/data/exttab_first_errors.data: "error_0"
SELECT COUNT(*) > 0 from gp_read_error_log('exttab_first_reject_limit_2');
 ?column? 
----------
 t
(1 row)

-- set unlimited first error rows, should fail only because of segment reject limits
set gp_initial_bad_row_limit = 0;
SELECT gp_truncate_error_log('exttab_first_reject_limit_2');
 gp_truncate_error_log 
-----------------------
 t
(1 row)

SELECT COUNT(*) FROM exttab_first_reject_limit_2;
ERROR:  Segment reject limit reached. Aborting operation. Last error was: missing data for column "j"  (seg0 slice1 @hostname@:40000 pid=28213)
DETAIL:  External table exttab_first_reject_limit_2, line 500 of file://@hostname@@abs_srcdir@/data/exttab_first_errors.data: "error_0"
SELECT COUNT(*) > 0 from gp_read_error_log('exttab_first_reject_limit_2');
 ?column? 
----------
 t
(1 row)

DROP EXTERNAL TABLE IF EXISTS exttab_heap_join_1;
NOTICE:  table "exttab_heap_join_1" does not exist, skipping
-- does not reach reject limit
CREATE EXTERNAL TABLE exttab_heap_join_1( i int, j text ) 
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|') 
LOG ERRORS SEGMENT REJECT LIMIT 10;
DROP TABLE IF EXISTS test_ext_heap_join;
NOTICE:  table "test_ext_heap_join" does not exist, skipping
CREATE TABLE test_ext_heap_join( i int, j text);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'i' as the Greenplum Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
-- Turn off stats 
SET gp_autostats_mode = 'NONE';
INSERT INTO test_ext_heap_join SELECT i, i || '_number' FROM generate_series(1, 10) i;
SELECT COUNT(*) FROM test_ext_heap_join, exttab_heap_join_1;
NOTICE:  Found 2 data formatting errors (2 or more input rows). Rejected related input data.
 count 
-------
    80
(1 row)

SELECT COUNT(*) FROM gp_read_error_log('exttab_heap_join_1');
 count 
-------
     2
(1 row)

\! rm @abs_srcdir@/data/tableless.csv
-- Create external table with 'OPTIONS'
CREATE EXTERNAL TABLE exttab_with_option_empty( i int, j text )
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|')
OPTIONS ();
CREATE EXTERNAL TABLE exttab_with_option_1( i int, j text )
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|')
OPTIONS (hello 'world');
CREATE EXTERNAL TABLE exttab_with_options( i int, j text )
LOCATION ('file://@hostname@@abs_srcdir@/data/exttab_few_errors.data') FORMAT 'TEXT' (DELIMITER '|')
OPTIONS (hello 'world', bonjour 'again', nihao 'again and again' );
\d exttab_with_options 
External table "public.exttab_with_options"
 Column |  Type   | Modifiers 
--------+---------+-----------
 i      | integer | 
 j      | text    | 
Type: readable
Encoding: UTF8
Format type: text
Format options: delimiter '|' null '\N' escape '\'
External options: {hello=world,bonjour=again,"nihao=again and again"} 
External location: file://@hostname@@abs_srcdir@/data/exttab_few_errors.data 

\d exttab_with_option_empty 
External table "public.exttab_with_option_empty"
 Column |  Type   | Modifiers 
--------+---------+-----------
 i      | integer | 
 j      | text    | 
Type: readable
Encoding: UTF8
Format type: text
Format options: delimiter '|' null '\N' escape '\'
External options: {} 
External location: file://@hostname@@abs_srcdir@/data/exttab_few_errors.data

DROP EXTERNAL TABLE IF EXISTS exttab_with_option_empty;
DROP EXTERNAL TABLE IF EXISTS exttab_with_option_1;
DROP EXTERNAL TABLE IF EXISTS exttab_with_options;
-- start_ignore
-- drop temp external protocols
DROP PROTOCOL if exists demoprot;
DROP PROTOCOL if exists demoprot2;
NOTICE:  protocol "demoprot2" does not exist, skipping
-- end_ignore
-- create external protocol
CREATE OR REPLACE FUNCTION write_to_file() RETURNS integer as '$libdir/gpextprotocol.so', 'demoprot_export' LANGUAGE C STABLE NO SQL;
CREATE OR REPLACE FUNCTION read_from_file() RETURNS integer as '$libdir/gpextprotocol.so', 'demoprot_import' LANGUAGE C STABLE NO SQL;
CREATE TRUSTED PROTOCOL demoprot (readfunc = 'read_from_file', writefunc = 'write_to_file');
-- alter external protocol's name
ALTER PROTOCOL demoprot RENAME TO demoprot2;
-- type name is a fixed-length string padded by '\0', normal(wrong)
-- renaming will make cdbhash() getting different values, select
-- displaying more than oneline here
select distinct ptcname from (
        select ptcname AS ptcname from gp_dist_random('pg_extprotocol')
) all_segments where ptcname = 'demoprot2';
  ptcname
-----------
 demoprot2
(1 row)

-- drop temp external protocols
DROP PROTOCOL if exists demoprot;
NOTICE:  protocol "demoprot" does not exist, skipping
DROP PROTOCOL if exists demoprot2;
-- create external protocol with a serial type column
CREATE EXTERNAL TABLE SERIAL (a serial, x text)
LOCATION ('file://@hostname@@abs_srcdir@/data/no/such/place/serial.tbl')
FORMAT 'csv';
NOTICE:  CREATE EXTERNAL TABLE will create implicit sequence "serial_a_seq" for serial column "serial.a"
-- drop temp external table
DROP EXTERNAL TABLE IF EXISTS serial;
