<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="functions-matching">
  <title>Pattern Matching</title>
  <body>
    <p> There are three separate approaches to pattern matching provided by Greenplum Database: the
      traditional SQL <codeph>LIKE</codeph> operator, the more recent <codeph>SIMILAR TO</codeph>
      operator (added in SQL:1999), and POSIX-style regular expressions. Additionally, a pattern
      matching function, <codeph>substring</codeph>, is available, using either <codeph>SIMILAR
        TO</codeph>-style or POSIX-style regular expressions. </p>
    <note type="tip">
      <p> If you have pattern matching needs that go beyond this, consider writing a user-defined
        function in Perl or Tcl. </p>
    </note>
  </body>
  <topic id="functions-like">
    <title> LIKE </title>
    <body>
      <codeblock>
<i>string</i> LIKE <i>pattern</i> [ESCAPE <i>escape-character</i>]
<i>string</i> NOT LIKE <i>pattern</i> [ESCAPE <i>escape-character</i>]
</codeblock>
      <p> Every <i>pattern</i> defines a set of strings. The <codeph>LIKE</codeph> expression
        returns true if the <i>string</i> is contained in the set of strings represented by
          <i>pattern</i>. (As expected, the <codeph>NOT LIKE</codeph> expression returns false if
          <codeph>LIKE</codeph> returns true, and vice versa. An equivalent expression is
          <codeph>NOT (<i>string</i> LIKE <i>pattern</i>)</codeph>.) </p>
      <p> If <i>pattern</i> does not contain percent signs or underscore, then the pattern only
        represents the string itself; in that case <codeph>LIKE</codeph> acts like the equals
        operator. An underscore (<codeph>_</codeph>) in <i>pattern</i> stands for (matches) any
        single character; a percent sign (<codeph>%</codeph>) matches any string of zero or more
        characters. </p>
      <p> Some examples:
        <codeblock>
'abc' LIKE 'abc'    <b>true</b>
'abc' LIKE 'a%'     <b>true</b>
'abc' LIKE '_b_'    <b>true</b>
'abc' LIKE 'c'      <b>false</b>
</codeblock>
      </p>
      <p>
        <codeph>LIKE</codeph> pattern matches always cover the entire string. To match a sequence
        anywhere within a string, the pattern must therefore start and end with a percent sign. </p>
      <p> To match a literal underscore or percent sign without matching other characters, the
        respective character in <i>pattern</i> must be preceded by the escape character. The default
        escape character is the backslash but a different one may be selected by using the
          <codeph>ESCAPE</codeph> clause. To match the escape character itself, write two escape
        characters. </p>
      <p> Note that the backslash already has a special meaning in string literals, so to write a
        pattern constant that contains a backslash you must write two backslashes in an SQL
        statement (assuming escape string syntax is used). Thus, writing a pattern that actually
        matches a literal backslash means writing four backslashes in the statement. You can avoid
        this by selecting a different escape character with <codeph>ESCAPE</codeph>; then a
        backslash is not special to <codeph>LIKE</codeph> anymore. (But it is still special to the
        string literal parser, so you still need two of them.) </p>
      <p> It's also possible to select no escape character by writing <codeph>ESCAPE ''</codeph>.
        This effectively disables the escape mechanism, which makes it impossible to turn off the
        special meaning of underscore and percent signs in the pattern. </p>
      <p> The key word <codeph>ILIKE</codeph> can be used instead of <codeph>LIKE</codeph> to make
        the match case-insensitive according to the active locale. This is not in the SQL standard
        but is a Greenplum Database extension. </p>
      <p> The operator <codeph>~~</codeph> is equivalent to <codeph>LIKE</codeph>, and
          <codeph>~~*</codeph> corresponds to <codeph>ILIKE</codeph>. There are also
          <codeph>!~~</codeph> and <codeph>!~~*</codeph> operators that represent <codeph>NOT
          LIKE</codeph> and <codeph>NOT ILIKE</codeph>, respectively. All of these operators are
        Greenplum Database-specific. </p>
    </body>
  </topic>
  <topic id="functions-similarto-regexp">
    <title>SIMILAR TO Regular Expressions</title>
    <body>
      <codeblock>
<i>string</i> SIMILAR TO <i>pattern</i> [ESCAPE <i>escape-character</i>]
<i>string</i> NOT SIMILAR TO <i>pattern</i> [ESCAPE <i>escape-character</i>]
</codeblock>
      <p> The <codeph>SIMILAR TO</codeph> operator returns true or false depending on whether its
        pattern matches the given string. It is much like <codeph>LIKE</codeph>, except that it
        interprets the pattern using the SQL standard's definition of a regular expression. SQL
        regular expressions are a curious cross between <codeph>LIKE</codeph> notation and common
        regular expression notation. </p>
      <p> Like <codeph>LIKE</codeph>, the <codeph>SIMILAR TO</codeph> operator succeeds only if its
        pattern matches the entire string; this is unlike common regular expression practice,
        wherein the pattern may match any part of the string. Also like <codeph>LIKE</codeph>,
          <codeph>SIMILAR TO</codeph> uses <codeph>_</codeph> and <codeph>%</codeph> as wildcard
        characters denoting any single character and any string, respectively (these are comparable
        to <codeph>.</codeph> and <codeph>.*</codeph> in POSIX regular expressions). </p>
      <p> In addition to these facilities borrowed from <codeph>LIKE</codeph>, <codeph>SIMILAR
          TO</codeph> supports these pattern-matching metacharacters borrowed from POSIX regular
        expressions: <ul>
          <li>
            <p>
              <codeph>|</codeph> denotes alternation (either of two alternatives). </p>
          </li>
          <li>
            <p>
              <codeph>*</codeph> denotes repetition of the previous item zero or more times. </p>
          </li>
          <li>
            <p>
              <codeph>+</codeph> denotes repetition of the previous item one or more times. </p>
          </li>
          <li>
            <p> Parentheses <codeph>()</codeph> may be used to group items into a single logical
              item. </p>
          </li>
          <li>
            <p> A bracket expression <codeph>[...]</codeph> specifies a character class, just as in
              POSIX regular expressions. </p>
          </li>
        </ul> Notice that bounded repetition (<codeph>?</codeph> and <codeph>{...}</codeph>) are not
        provided, though they exist in POSIX. Also, the dot (<codeph>.</codeph>) is not a
        metacharacter. </p>
      <p> As with <codeph>LIKE</codeph>, a backslash disables the special meaning of any of these
        metacharacters; or a different escape character can be specified with
          <codeph>ESCAPE</codeph>. </p>
      <p> Some examples:
        <codeblock>
'abc' SIMILAR TO 'abc'      <b>true</b>
'abc' SIMILAR TO 'a'        <b>false</b>
'abc' SIMILAR TO '%(b|d)%'  <b>true</b>
'abc' SIMILAR TO '(b|c)%'   <b>false</b>
</codeblock>
      </p>
      <p> The <codeph>substring</codeph> function with three parameters,
            <codeph>substring(<i>string</i> from <i>pattern</i> for
          <i>escape-character</i>)</codeph>, provides extraction of a substring that matches an SQL
        regular expression pattern. As with <codeph>SIMILAR TO</codeph>, the specified pattern must
        match to the entire data string, else the function fails and returns null. To indicate the
        part of the pattern that should be returned on success, the pattern must contain two
        occurrences of the escape character followed by a double quote (<codeph>"</codeph>). The
        text matching the portion of the pattern between these markers is returned. </p>
      <p> Some examples:
        <codeblock>
substring('foobar' from '%#"o_b#"%' for '#')   <b>oob</b>
substring('foobar' from '#"o_b#"%' for '#')    <b>NULL</b>
</codeblock>
      </p>
    </body>
  </topic>
  <topic id="functions-posix-regexp">
    <title>POSIX Regular Expressions</title>
    <body>
      <p>
        <xref href="#functions-posix-regexp/functions-posix-table" format="dita"/> lists the
        available operators for pattern matching using POSIX regular expressions. </p>
      <table id="functions-posix-table">
        <title>Regular Expression Match Operators</title>
        <tgroup cols="3">
          <colspec colnum="1" colname="c1" colwidth="25*"/>
          <colspec colnum="2" colname="c2" colwidth="42*"/>
          <colspec colnum="3" colname="c3" colwidth="41*"/>
          <thead>
            <row>
              <entry>Operator</entry>
              <entry>Description</entry>
              <entry>Example</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <codeph>~</codeph>
              </entry>
              <entry>Matches regular expression, case sensitive</entry>
              <entry>
                <codeph>'thomas' ~ '.*thomas.*'</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>~*</codeph>
              </entry>
              <entry>Matches regular expression, case insensitive</entry>
              <entry>
                <codeph>'thomas' ~* '.*Thomas.*'</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>!~</codeph>
              </entry>
              <entry>Does not match regular expression, case sensitive</entry>
              <entry>
                <codeph>'thomas' !~ '.*Thomas.*'</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>!~*</codeph>
              </entry>
              <entry>Does not match regular expression, case insensitive</entry>
              <entry>
                <codeph>'thomas' !~* '.*vadim.*'</codeph>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <p> POSIX regular expressions provide a more powerful means for pattern matching than the
          <codeph>LIKE</codeph> and <codeph>SIMILAR TO</codeph> operators. Many Unix tools such as
          <cmdname>egrep</cmdname>, <cmdname>sed</cmdname>, or <cmdname>awk</cmdname> use a pattern
        matching language that is similar to the one described here. </p>
      <p> A regular expression is a character sequence that is an abbreviated definition of a set of
        strings (a <i>regular set</i>). A string is said to match a regular expression if it is a
        member of the regular set described by the regular expression. As with
        <codeph>LIKE</codeph>, pattern characters match string characters exactly unless they are
        special characters in the regular expression language -- but regular expressions use
        different special characters than <codeph>LIKE</codeph> does. Unlike <codeph>LIKE</codeph>
        patterns, a regular expression is allowed to match anywhere within a string, unless the
        regular expression is explicitly anchored to the beginning or end of the string. </p>
      <p> Some examples:
        <codeblock>
'abc' ~ 'abc'    <b>true</b>
'abc' ~ '^a'     <b>true</b>
'abc' ~ '(b|d)'  <b>true</b>
'abc' ~ '^(b|c)' <b>false</b>
</codeblock>
      </p>
      <p>The <codeph>substring</codeph> function with two parameters,
            <codeph>substring(<i>string</i> from <i>pattern</i>)</codeph>, provides extraction of a
        substring that matches a POSIX regular expression pattern. It returns null if there is no
        match, otherwise the portion of the text that matched the pattern. But if the pattern
        contains any parentheses, the portion of the text that matched the first parenthesized
        subexpression (the one whose left parenthesis comes first) is returned. You can put
        parentheses around the whole expression if you want to use parentheses within it without
        triggering this exception. If you need parentheses in the pattern before the subexpression
        you want to extract, see the non-capturing parentheses described below. </p>
      <p> Some examples:
        <codeblock>
substring('foobar' from 'o.b')     <b>oob</b>
substring('foobar' from 'o(.)b')   <b>o</b>
</codeblock>
      </p>
      <p>The <codeph>regexp_replace</codeph> function provides substitution of new text for
        substrings that match POSIX regular expression patterns. It has the syntax
          <codeph>regexp_replace</codeph>(<i>source</i>, <i>pattern</i>, <i>replacement</i> [,
          <i>flags</i> ]). The <i>source</i> string is returned unchanged if there is no match to
        the <i>pattern</i>. If there is a match, the <i>source</i> string is returned with the
          <i>replacement</i> string substituted for the matching substring. The <i>replacement</i>
        string can contain <codeph>\</codeph><i>n</i>, where <i>n</i> is <codeph>1</codeph> through
          <codeph>9</codeph>, to indicate that the source substring matching the <i>n</i>'th
        parenthesized subexpression of the pattern should be inserted, and it can contain
          <codeph>\&amp;</codeph> to indicate that the substring matching the entire pattern should
        be inserted. Write <codeph>\\</codeph> if you need to put a literal backslash in the
        replacement text. (As always, remember to double backslashes written in literal constant
        strings, assuming escape string syntax is used.) The <i>flags</i> parameter is an optional
        text string containing zero or more single-letter flags that change the function's behavior.
        Flag <codeph>i</codeph> specifies case-insensitive matching, while flag <codeph>g</codeph>
        specifies replacement of each matching substring rather than only the first one. </p>
      <p> Some examples:
        <codeblock>
regexp_replace('foobarbaz', 'b..', 'X')
                                   <b>fooXbaz</b>
regexp_replace('foobarbaz', 'b..', 'X', 'g')
                                   <b>fooXX</b>
regexp_replace('foobarbaz', 'b(..)', E'X\\1Y', 'g')
                                   <b>fooXarYXazY</b>
</codeblock>
      </p>
      <p> Greenplum Database's regular expressions are implemented using a package written by Henry
        Spencer. Much of the description of regular expressions below is copied verbatim from his
        manual entry. </p>
    </body>
    <topic id="posix-syntax-details">
      <title>Regular Expression Details </title>
      <body>
        <p> Regular expressions (REs), as defined in POSIX 1003.2, come in two forms:
            <i>extended</i> REs or EREs (roughly those of <cmdname>egrep</cmdname>), and
            <i>basic</i> REs or BREs (roughly those of <cmdname>ed</cmdname>). Greenplum Database
          supports both forms, and also implements some extensions that are not in the POSIX
          standard, but have become widely used anyway due to their availability in programming
          languages such as Perl and Tcl. REs using these non-POSIX extensions are called
            <i>advanced</i> REs or AREs in this documentation. AREs are almost an exact superset of
          EREs, but BREs have several notational incompatibilities (as well as being much more
          limited). We first describe the ARE and ERE forms, noting features that apply only to
          AREs, and then describe how BREs differ. </p>
        <note> The form of regular expressions accepted by Greenplum Database can be chosen by
          setting the <xref href="../guc_config.xml#regex_flavor"/> run-time parameter. The usual
          setting is <codeph>advanced</codeph>. </note>
        <p> A regular expression is defined as one or more <i>branches</i>, separated by
            <codeph>|</codeph>. It matches anything that matches one of the branches. </p>
        <p> A branch is zero or more <i>quantified atoms</i> or <i>constraints</i>, concatenated. It
          matches a match for the first, followed by a match for the second, etc; an empty branch
          matches the empty string. </p>
        <p> A quantified atom is an <i>atom</i> possibly followed by a single <i>quantifier</i>.
          Without a quantifier, it matches a match for the atom. With a quantifier, it can match
          some number of matches of the atom. An <i>atom</i> can be any of the possibilities shown
          in <xref href="#posix-syntax-details/posix-atoms-table" format="dita"/>. The possible
          quantifiers and their meanings are shown in <xref
            href="#posix-syntax-details/posix-quantifiers-table" format="dita"/>. </p>
        <p> A <i>constraint</i> matches an empty string, but matches only when specific conditions
          are met. A constraint can be used where an atom could be used, except it may not be
          followed by a quantifier. The simple constraints are shown in <xref
            href="#posix-syntax-details/posix-constraints-table" format="dita"/>; some more
          constraints are described later. </p>
        <table id="posix-atoms-table">
          <title>Regular Expression Atoms</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="1*"/>
            <colspec colnum="2" colname="c2" colwidth="2.77*"/>
            <thead>
              <row>
                <entry>Atom</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>(</codeph>
                  <i>re</i>
                  <codeph>)</codeph>
                </entry>
                <entry> (where <i>re</i> is any regular expression) matches a match for <i>re</i>,
                  with the match noted for possible reporting </entry>
              </row>
              <row>
                <entry>
                  <codeph>(?:</codeph>
                  <i>re</i>
                  <codeph>)</codeph>
                </entry>
                <entry> as above, but the match is not noted for reporting (a "non-capturing" set of
                  parentheses) (AREs only) </entry>
              </row>
              <row>
                <entry>
                  <codeph>.</codeph>
                </entry>
                <entry> matches any single character </entry>
              </row>
              <row>
                <entry>
                  <codeph>[</codeph>
                  <i>chars</i>
                  <codeph>]</codeph>
                </entry>
                <entry> a <i>bracket expression</i>, matching any one of the <i>chars</i> (see <xref
                    href="#posix-bracket-expressions" format="dita"/> for more detail) </entry>
              </row>
              <row>
                <entry>
                  <codeph>\</codeph>
                  <i>k</i>
                </entry>
                <entry> (where <i>k</i> is a non-alphanumeric character) matches that character
                  taken as an ordinary character, e.g. <codeph>\\</codeph> matches a backslash
                  character </entry>
              </row>
              <row>
                <entry>
                  <codeph>\</codeph>
                  <i>c</i>
                </entry>
                <entry> where <i>c</i> is alphanumeric (possibly followed by other characters) is an
                    <i>escape</i>, see <xref href="#posix-escape-sequences" format="dita"/> (AREs
                  only; in EREs and BREs, this matches <i>c</i>) </entry>
              </row>
              <row>
                <entry>
                  <codeph>{</codeph>
                </entry>
                <entry> when followed by a character other than a digit, matches the left-brace
                  character <codeph>{</codeph>; when followed by a digit, it is the beginning of a
                    <i>bound</i> (see below) </entry>
              </row>
              <row>
                <entry>
                  <i>x</i>
                </entry>
                <entry> where <i>x</i> is a single character with no other significance, matches
                  that character </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <p> An RE may not end with <codeph>\</codeph>. </p>
        <note>
          <p> Remember that the backslash (<codeph>\</codeph>) already has a special meaning in
            Greenplum Database string literals. To write a pattern constant that contains a
            backslash, you must write two backslashes in the statement, assuming escape string
            syntax is used. </p>
        </note>
        <table id="posix-quantifiers-table">
          <title>Regular Expression Quantifiers</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="1*"/>
            <colspec colnum="2" colname="c2" colwidth="1.3*"/>
            <thead>
              <row>
                <entry>Quantifier</entry>
                <entry>Matches</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>*</codeph>
                </entry>
                <entry> a sequence of 0 or more matches of the atom </entry>
              </row>
              <row>
                <entry>
                  <codeph>+</codeph>
                </entry>
                <entry> a sequence of 1 or more matches of the atom </entry>
              </row>
              <row>
                <entry>
                  <codeph>?</codeph>
                </entry>
                <entry> a sequence of 0 or 1 matches of the atom </entry>
              </row>
              <row>
                <entry>
                  <codeph>{</codeph>
                  <i>m</i>
                  <codeph>}</codeph>
                </entry>
                <entry> a sequence of exactly <i>m</i> matches of the atom </entry>
              </row>
              <row>
                <entry>
                  <codeph>{</codeph>
                  <i>m</i>
                  <codeph>,}</codeph>
                </entry>
                <entry> a sequence of <i>m</i> or more matches of the atom </entry>
              </row>
              <row>
                <entry>
                  <codeph>{</codeph>
                  <i>m</i>
                  <codeph>,</codeph>
                  <i>n</i>
                  <codeph>}</codeph>
                </entry>
                <entry> a sequence of <i>m</i> through <i>n</i> (inclusive) matches of the atom;
                    <i>m</i> may not exceed <i>n</i>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>*?</codeph>
                </entry>
                <entry> non-greedy version of <codeph>*</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>+?</codeph>
                </entry>
                <entry> non-greedy version of <codeph>+</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>??</codeph>
                </entry>
                <entry> non-greedy version of <codeph>?</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>{</codeph>
                  <i>m</i>
                  <codeph>}?</codeph>
                </entry>
                <entry> non-greedy version of <codeph>{</codeph><i>m</i><codeph>}</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>{</codeph>
                  <i>m</i>
                  <codeph>,}?</codeph>
                </entry>
                <entry> non-greedy version of <codeph>{</codeph><i>m</i><codeph>,}</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>{</codeph>
                  <i>m</i>
                  <codeph>,</codeph>
                  <i>n</i>
                  <codeph>}?</codeph>
                </entry>
                <entry> non-greedy version of
                    <codeph>{</codeph><i>m</i><codeph>,</codeph><i>n</i><codeph>}</codeph>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <p> The forms using <codeph>{</codeph><i>...</i><codeph>}</codeph> are known as
            <i>bounds</i>. The numbers <i>m</i> and <i>n</i> within a bound are unsigned decimal
          integers with permissible values from 0 to 255 inclusive. </p>
        <p>
          <i>Non-greedy</i> quantifiers (available in AREs only) match the same possibilities as
          their corresponding normal (<i>greedy</i>) counterparts, but prefer the smallest number
          rather than the largest number of matches. See <xref href="#posix-matching-rules"/> for
          more detail. </p>
        <note>
          <p> A quantifier cannot immediately follow another quantifier. A quantifier cannot begin
            an expression or subexpression or follow <codeph>^</codeph> or <codeph>|</codeph>. </p>
        </note>
        <table id="posix-constraints-table">
          <title>Regular Expression Constraints</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="1*"/>
            <colspec colnum="2" colname="c2" colwidth="1.82*"/>
            <thead>
              <row>
                <entry>Constraint</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>^</codeph>
                </entry>
                <entry> matches at the beginning of the string </entry>
              </row>
              <row>
                <entry>
                  <codeph>$</codeph>
                </entry>
                <entry> matches at the end of the string </entry>
              </row>
              <row>
                <entry>
                  <codeph>(?=</codeph>
                  <i>re</i>
                  <codeph>)</codeph>
                </entry>
                <entry>
                  <i>positive lookahead</i> matches at any point where a substring matching
                    <i>re</i> begins (AREs only) </entry>
              </row>
              <row>
                <entry>
                  <codeph>(?!</codeph>
                  <i>re</i>
                  <codeph>)</codeph>
                </entry>
                <entry>
                  <i>negative lookahead</i> matches at any point where no substring matching
                    <i>re</i> begins (AREs only) </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <p> Lookahead constraints may not contain <i>back references</i> (see <xref
            href="#posix-escape-sequences"/>), and all parentheses within them are considered
          non-capturing. </p>
      </body>
    </topic>
    <topic id="posix-bracket-expressions">
      <title>Bracket Expressions</title>
      <body>
        <p> A <i>bracket expression</i> is a list of characters enclosed in <codeph>[]</codeph>. It
          normally matches any single character from the list (but see below). If the list begins
          with <codeph>^</codeph>, it matches any single character <i>not</i> from the rest of the
          list. If two characters in the list are separated by <codeph>-</codeph>, this is shorthand
          for the full range of characters between those two (inclusive) in the collating sequence,
          e.g. <codeph>[0-9]</codeph> in ASCII matches any decimal digit. It is illegal for two
          ranges to share an endpoint, e.g. <codeph>a-c-e</codeph>. Ranges are very
          collating-sequence-dependent, so portable programs should avoid relying on them. </p>
        <p> To include a literal <codeph>]</codeph> in the list, make it the first character
          (following a possible <codeph>^</codeph>). To include a literal <codeph>-</codeph>, make
          it the first or last character, or the second endpoint of a range. To use a literal
            <codeph>-</codeph> as the first endpoint of a range, enclose it in <codeph>[.</codeph>
          and <codeph>.]</codeph> to make it a collating element (see below). With the exception of
          these characters, some combinations using <codeph>[</codeph> (see next paragraphs), and
          escapes (AREs only), all other special characters lose their special significance within a
          bracket expression. In particular, <codeph>\</codeph> is not special when following ERE or
          BRE rules, though it is special (as introducing an escape) in AREs. </p>
        <p> Within a bracket expression, a collating element (a character, a multiple-character
          sequence that collates as if it were a single character, or a collating-sequence name for
          either) enclosed in <codeph>[.</codeph> and <codeph>.]</codeph> stands for the sequence of
          characters of that collating element. The sequence is a single element of the bracket
          expression's list. A bracket expression containing a multiple-character collating element
          can thus match more than one character, e.g. if the collating sequence includes a
            <codeph>ch</codeph> collating element, then the RE <codeph>[[.ch.]]*c</codeph> matches
          the first five characters of <codeph>chchcc</codeph>. </p>
        <note>
          <p> Greenplum Database currently has no multicharacter collating elements. This
            information describes possible future behavior. </p>
        </note>
        <p> Within a bracket expression, a collating element enclosed in <codeph>[=</codeph> and
            <codeph>=]</codeph> is an equivalence class, standing for the sequences of characters of
          all collating elements equivalent to that one, including itself. (If there are no other
          equivalent collating elements, the treatment is as if the enclosing delimiters were
            <codeph>[.</codeph> and <codeph>.]</codeph>.) For example, if <codeph>o</codeph> and
            <codeph>^</codeph> are the members of an equivalence class, then
            <codeph>[[=o=]]</codeph>, <codeph>[[=^=]]</codeph>, and <codeph>[o^]</codeph> are all
          synonymous. An equivalence class may not be an endpoint of a range. </p>
        <p> Within a bracket expression, the name of a character class enclosed in
            <codeph>[:</codeph> and <codeph>:]</codeph> stands for the list of all characters
          belonging to that class. Standard character class names are: <codeph>alnum</codeph>,
            <codeph>alpha</codeph>, <codeph>blank</codeph>, <codeph>cntrl</codeph>,
            <codeph>digit</codeph>, <codeph>graph</codeph>, <codeph>lower</codeph>,
            <codeph>print</codeph>, <codeph>punct</codeph>, <codeph>space</codeph>,
            <codeph>upper</codeph>, <codeph>xdigit</codeph>. These stand for the character classes
          defined in <i>ctype (3)</i>. A locale may provide others. A character class may not be
          used as an endpoint of a range. </p>
        <p> There are two special cases of bracket expressions: the bracket expressions
            <codeph>[[:&lt;:]]</codeph> and <codeph>[[:&gt;:]]</codeph> are constraints, matching
          empty strings at the beginning and end of a word respectively. A word is defined as a
          sequence of word characters that is neither preceded nor followed by word characters. A
          word character is an <codeph>alnum</codeph> character (as defined by <cite>ctype
            (3)</cite> ) or an underscore. This is an extension, compatible with but not specified
          by POSIX 1003.2, and should be used with caution in software intended to be portable to
          other systems. The constraint escapes described below are usually preferable (they are no
          more standard, but are certainly easier to type). </p>
      </body>
    </topic>
    <topic id="posix-escape-sequences">
      <title>Regular Expression Escapes</title>
      <body>
        <p>
          <i>Escapes</i> are special sequences beginning with <codeph>\</codeph> followed by an
          alphanumeric character. Escapes come in several varieties: character entry, class
          shorthands, constraint escapes, and back references. A <codeph>\</codeph> followed by an
          alphanumeric character but not constituting a valid escape is illegal in AREs. In EREs,
          there are no escapes: outside a bracket expression, a <codeph>\</codeph> followed by an
          alphanumeric character merely stands for that character as an ordinary character, and
          inside a bracket expression, <codeph>\</codeph> is an ordinary character. (The latter is
          the one actual incompatibility between EREs and AREs.) </p>
        <p>
          <i>Character-entry escapes</i> exist to make it easier to specify non-printing and
          otherwise inconvenient characters in REs. They are shown in <xref
            href="#posix-escape-sequences/posix-character-entry-escapes-table" format="dita"/>. </p>
        <p>
          <i>Class-shorthand escapes</i> provide shorthands for certain commonly-used character
          classes. They are shown in <xref
            href="#posix-escape-sequences/posix-class-shorthand-escapes-table" format="dita"/>. </p>
        <p> A <i>constraint escape</i> is a constraint, matching the empty string if specific
          conditions are met, written as an escape. They are shown in <xref
            href="#posix-escape-sequences/posix-constraint-escapes-table" format="dita"/>. </p>
        <p> A <i>back reference</i> (<codeph>\</codeph><i>n</i>) matches the same string matched by
          the previous parenthesized subexpression specified by the number <i>n</i> (see <xref
            href="#posix-escape-sequences/posix-constraint-backref-table" format="dita"/>). For
          example, <codeph>([bc])\1</codeph> matches <codeph>bb</codeph> or <codeph>cc</codeph> but
          not <codeph>bc</codeph> or <codeph>cb</codeph>. The subexpression must entirely precede
          the back reference in the RE. Subexpressions are numbered in the order of their leading
          parentheses. Non-capturing parentheses do not define subexpressions. </p>
        <note>
          <p> Keep in mind that an escape's leading <codeph>\</codeph> will need to be doubled when
            entering the pattern as an SQL string constant. For example:
            <codeblock>
'123' ~ E'^\\d{3}' <b>true</b>
</codeblock>
          </p>
        </note>
        <table id="posix-character-entry-escapes-table">
          <title>Regular Expression Character-Entry Escapes</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="1*"/>
            <colspec colnum="2" colname="c2" colwidth="3.44*"/>
            <thead>
              <row>
                <entry>Escape</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>\a</codeph>
                </entry>
                <entry> alert (bell) character, as in C </entry>
              </row>
              <row>
                <entry>
                  <codeph>\b</codeph>
                </entry>
                <entry> backspace, as in C </entry>
              </row>
              <row>
                <entry>
                  <codeph>\B</codeph>
                </entry>
                <entry> synonym for <codeph>\</codeph> to help reduce the need for backslash
                  doubling </entry>
              </row>
              <row>
                <entry>
                  <codeph>\c</codeph>
                  <i>X</i>
                </entry>
                <entry> (where <i>X</i> is any character) the character whose low-order 5 bits are
                  the same as those of <i>X</i>, and whose other bits are all zero </entry>
              </row>
              <row>
                <entry>
                  <codeph>\e</codeph>
                </entry>
                <entry> the character whose collating-sequence name is <codeph>ESC</codeph>, or
                  failing that, the character with octal value 033 </entry>
              </row>
              <row>
                <entry>
                  <codeph>\f</codeph>
                </entry>
                <entry> form feed, as in C </entry>
              </row>
              <row>
                <entry>
                  <codeph>\n</codeph>
                </entry>
                <entry> newline, as in C </entry>
              </row>
              <row>
                <entry>
                  <codeph>\r</codeph>
                </entry>
                <entry> carriage return, as in C </entry>
              </row>
              <row>
                <entry>
                  <codeph>\t</codeph>
                </entry>
                <entry> horizontal tab, as in C </entry>
              </row>
              <row>
                <entry>
                  <codeph>\u</codeph>
                  <i>wxyz</i>
                </entry>
                <entry> (where <i>wxyz</i> is exactly four hexadecimal digits) the UTF16 (Unicode,
                  16-bit) character <codeph>U+</codeph><i>wxyz</i> in the local byte ordering
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>\U</codeph>
                  <i>stuvwxyz</i>
                </entry>
                <entry> (where <i>stuvwxyz</i> is exactly eight hexadecimal digits) reserved for a
                  somewhat-hypothetical Unicode extension to 32 bits </entry>
              </row>
              <row>
                <entry>
                  <codeph>\v</codeph>
                </entry>
                <entry> vertical tab, as in C </entry>
              </row>
              <row>
                <entry>
                  <codeph>\x</codeph>
                  <i>hhh</i>
                </entry>
                <entry> (where <i>hhh</i> is any sequence of hexadecimal digits) the character whose
                  hexadecimal value is <codeph>0x</codeph><i>hhh</i> (a single character no matter
                  how many hexadecimal digits are used) </entry>
              </row>
              <row>
                <entry>
                  <codeph>\0</codeph>
                </entry>
                <entry> the character whose value is <codeph>0</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>\</codeph>
                  <i>xy</i>
                </entry>
                <entry> (where <i>xy</i> is exactly two octal digits, and is not a <i>back
                    reference</i>) the character whose octal value is <codeph>0</codeph><i>xy</i>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>\</codeph>
                  <i>xyz</i>
                </entry>
                <entry> (where <i>xyz</i> is exactly three octal digits, and is not a <i>back
                    reference</i>) the character whose octal value is <codeph>0</codeph><i>xyz</i>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <p> Hexadecimal digits are <codeph>0</codeph>-<codeph>9</codeph>,
            <codeph>a</codeph>-<codeph>f</codeph>, and <codeph>A</codeph>-<codeph>F</codeph>. Octal
          digits are <codeph>0</codeph>-<codeph>7</codeph>. </p>
        <p> The character-entry escapes are always taken as ordinary characters. For example,
            <codeph>\135</codeph> is <codeph>]</codeph> in ASCII, but <codeph>\135</codeph> does not
          terminate a bracket expression. </p>
        <table id="posix-class-shorthand-escapes-table">
          <title>Regular Expression Class-Shorthand Escapes</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="1*"/>
            <colspec colnum="2" colname="c2" colwidth="2.13*"/>
            <thead>
              <row>
                <entry>Escape</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>\d</codeph>
                </entry>
                <entry>
                  <codeph>[[:digit:]]</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>\s</codeph>
                </entry>
                <entry>
                  <codeph>[[:space:]]</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>\w</codeph>
                </entry>
                <entry>
                  <codeph>[[:alnum:]_]</codeph> (note underscore is included) </entry>
              </row>
              <row>
                <entry>
                  <codeph>\D</codeph>
                </entry>
                <entry>
                  <codeph>[^[:digit:]]</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>\S</codeph>
                </entry>
                <entry>
                  <codeph>[^[:space:]]</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>\W</codeph>
                </entry>
                <entry>
                  <codeph>[^[:alnum:]_]</codeph> (note underscore is included) </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <p> Within bracket expressions, <codeph>\d</codeph>, <codeph>\s</codeph>, and
            <codeph>\w</codeph> lose their outer brackets, and <codeph>\D</codeph>,
            <codeph>\S</codeph>, and <codeph>\W</codeph> are illegal. (So, for example,
            <codeph>[a-c\d]</codeph> is equivalent to <codeph>[a-c[:digit:]]</codeph>. Also,
            <codeph>[a-c\D]</codeph>, which is equivalent to <codeph>[a-c^[:digit:]]</codeph>, is
          illegal.) </p>
        <table id="posix-constraint-escapes-table">
          <title>Regular Expression Constraint Escapes</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="1*"/>
            <colspec colnum="2" colname="c2" colwidth="4.26*"/>
            <thead>
              <row>
                <entry>Escape</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>\A</codeph>
                </entry>
                <entry> matches only at the beginning of the string (see <xref
                    href="#posix-matching-rules"/> for how this differs from <codeph>^</codeph>)
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>\m</codeph>
                </entry>
                <entry> matches only at the beginning of a word </entry>
              </row>
              <row>
                <entry>
                  <codeph>\M</codeph>
                </entry>
                <entry> matches only at the end of a word </entry>
              </row>
              <row>
                <entry>
                  <codeph>\y</codeph>
                </entry>
                <entry> matches only at the beginning or end of a word </entry>
              </row>
              <row>
                <entry>
                  <codeph>\Y</codeph>
                </entry>
                <entry> matches only at a point that is not the beginning or end of a word </entry>
              </row>
              <row>
                <entry>
                  <codeph>\Z</codeph>
                </entry>
                <entry> matches only at the end of the string (see <xref
                    href="#posix-matching-rules"/> for how this differs from <codeph>$</codeph>)
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <p> A word is defined as in the specification of <codeph>[[:&lt;:]]</codeph> and
            <codeph>[[:&gt;:]]</codeph> above. Constraint escapes are illegal within bracket
          expressions. </p>
        <table id="posix-constraint-backref-table">
          <title>Regular Expression Back References</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="1*"/>
            <colspec colnum="2" colname="c2" colwidth="4.26*"/>
            <thead>
              <row>
                <entry>Escape</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>\</codeph>
                  <i>m</i>
                </entry>
                <entry> (where <i>m</i> is a nonzero digit) a back reference to the <i>m</i>'th
                  subexpression </entry>
              </row>
              <row>
                <entry>
                  <codeph>\</codeph>
                  <i>mnn</i>
                </entry>
                <entry> (where <i>m</i> is a nonzero digit, and <i>nn</i> is some more digits, and
                  the decimal value <i>mnn</i> is not greater than the number of closing capturing
                  parentheses seen so far) a back reference to the <i>mnn</i>'th subexpression
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <note>
          <p> There is an inherent historical ambiguity between octal character-entry escapes and
            back references, which is resolved by heuristics, as hinted at above. A leading zero
            always indicates an octal escape. A single non-zero digit, not followed by another
            digit, is always taken as a back reference. A multidigit sequence not starting with a
            zero is taken as a back reference if it comes after a suitable subexpression (i.e. the
            number is in the legal range for a back reference), and otherwise is taken as octal.
          </p>
        </note>
      </body>
    </topic>
    <topic id="posix-metasyntax">
      <title>Regular Expression Metasyntax</title>
      <body>
        <p> In addition to the main syntax described above, there are some special forms and
          miscellaneous syntactic facilities available. </p>
        <p> Normally the flavor of RE being used is determined by <varname>regex_flavor</varname>.
          However, this can be overridden by a <i>director</i> prefix. If an RE begins with
            <codeph>***:</codeph>, the rest of the RE is taken as an ARE regardless of
            <varname>regex_flavor</varname>. If an RE begins with <codeph>***=</codeph>, the rest of
          the RE is taken to be a literal string, with all characters considered ordinary
          characters. </p>
        <p> An ARE may begin with <i>embedded options</i>: a sequence
            <codeph>(?</codeph><i>xyz</i><codeph>)</codeph> (where <i>xyz</i> is one or more
          alphabetic characters) specifies options affecting the rest of the RE. These options
          override any previously determined options (including both the RE flavor and case
          sensitivity). The available option letters are shown in <xref
            href="#posix-metasyntax/posix-embedded-options-table" format="dita"/>. </p>
        <table id="posix-embedded-options-table">
          <title>ARE Embedded-Option Letters</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="c1" colwidth="1*"/>
            <colspec colnum="2" colname="c2" colwidth="3.44*"/>
            <thead>
              <row>
                <entry>Option</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>b</codeph>
                </entry>
                <entry> rest of RE is a BRE </entry>
              </row>
              <row>
                <entry>
                  <codeph>c</codeph>
                </entry>
                <entry> case-sensitive matching (overrides operator type) </entry>
              </row>
              <row>
                <entry>
                  <codeph>e</codeph>
                </entry>
                <entry> rest of RE is an ERE </entry>
              </row>
              <row>
                <entry>
                  <codeph>i</codeph>
                </entry>
                <entry> case-insensitive matching (see <xref href="#posix-matching-rules"/>)
                  (overrides operator type) </entry>
              </row>
              <row>
                <entry>
                  <codeph>m</codeph>
                </entry>
                <entry> historical synonym for <codeph>n</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>n</codeph>
                </entry>
                <entry> newline-sensitive matching (see ß) </entry>
              </row>
              <row>
                <entry>
                  <codeph>p</codeph>
                </entry>
                <entry> partial newline-sensitive matching (see <xref href="#posix-matching-rules"
                  />) </entry>
              </row>
              <row>
                <entry>
                  <codeph>q</codeph>
                </entry>
                <entry> rest of RE is a literal ("quoted") string, all ordinary characters </entry>
              </row>
              <row>
                <entry>
                  <codeph>s</codeph>
                </entry>
                <entry> non-newline-sensitive matching (default) </entry>
              </row>
              <row>
                <entry>
                  <codeph>t</codeph>
                </entry>
                <entry> tight syntax (default; see below) </entry>
              </row>
              <row>
                <entry>
                  <codeph>w</codeph>
                </entry>
                <entry> inverse partial newline-sensitive ("weird") matching (see <xref
                    href="#posix-matching-rules"/>) </entry>
              </row>
              <row>
                <entry>
                  <codeph>x</codeph>
                </entry>
                <entry> expanded syntax (see below) </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <p> Embedded options take effect at the <codeph>)</codeph> terminating the sequence. They
          may appear only at the start of an ARE (after the <codeph>***:</codeph> director if any). </p>
        <p> In addition to the usual (<i>tight</i>) RE syntax, in which all characters are
          significant, there is an <i>expanded</i> syntax, available by specifying the embedded
            <codeph>x</codeph> option. In the expanded syntax, white-space characters in the RE are
          ignored, as are all characters between a <codeph>#</codeph> and the following newline (or
          the end of the RE). This permits paragraphing and commenting a complex RE. There are three
          exceptions to that basic rule: <ul>
            <li>
              <p> a white-space character or <codeph>#</codeph> preceded by <codeph>\</codeph> is
                retained </p>
            </li>
            <li>
              <p> white space or <codeph>#</codeph> within a bracket expression is retained </p>
            </li>
            <li>
              <p> white space and comments cannot appear within multicharacter symbols, such as
                  <codeph>(?:</codeph>
              </p>
            </li>
          </ul> For this purpose, white-space characters are blank, tab, newline, and any character
          that belongs to the <i>space</i> character class. </p>
        <p> Finally, in an ARE, outside bracket expressions, the sequence
            <codeph>(?#</codeph><i>ttt</i><codeph>)</codeph> (where <i>ttt</i> is any text not
          containing a <codeph>)</codeph>) is a comment, completely ignored. Again, this is not
          allowed between the characters of multicharacter symbols, like <codeph>(?:</codeph>. Such
          comments are more a historical artifact than a useful facility, and their use is
          deprecated; use the expanded syntax instead. </p>
        <p>
          <i>None</i> of these metasyntax extensions is available if an initial
            <codeph>***=</codeph> director has specified that the user's input be treated as a
          literal string rather than as an RE. </p>
      </body>
    </topic>
    <topic id="posix-matching-rules">
      <title>Regular Expression Matching Rules</title>
      <body>
        <p> In the event that an RE could match more than one substring of a given string, the RE
          matches the one starting earliest in the string. If the RE could match more than one
          substring starting at that point, either the longest possible match or the shortest
          possible match will be taken, depending on whether the RE is <i>greedy</i> or
            <i>non-greedy</i>. </p>
        <p> Whether an RE is greedy or not is determined by the following rules: <ul
            id="ul_wq2_tx5_hp">
            <li> Most atoms, and all constraints, have no greediness attribute (because they cannot
              match variable amounts of text anyway). </li>
            <li> Adding parentheses around an RE does not change its greediness. </li>
            <li> A quantified atom with a fixed-repetition quantifier
                (<codeph>{</codeph><i>m</i><codeph>}</codeph> or
                <codeph>{</codeph><i>m</i><codeph>}?</codeph>) has the same greediness (possibly
              none) as the atom itself. </li>
            <li> A quantified atom with other normal quantifiers (including
                <codeph>{</codeph><i>m</i><codeph>,</codeph><i>n</i><codeph>}</codeph> with <i>m</i>
              equal to <i>n</i>) is greedy (prefers longest match). </li>
            <li> A quantified atom with a non-greedy quantifier (including
                <codeph>{</codeph><i>m</i><codeph>,</codeph><i>n</i><codeph>}?</codeph> with
                <i>m</i> equal to <i>n</i>) is non-greedy (prefers shortest match). </li>
            <li> A branch -- that is, an RE that has no top-level <codeph>|</codeph> operator -- has
              the same greediness as the first quantified atom in it that has a greediness
              attribute. </li>
            <li> An RE consisting of two or more branches connected by the <codeph>|</codeph>
              operator is always greedy. </li>
          </ul>
        </p>
        <p> The above rules associate greediness attributes not only with individual quantified
          atoms, but with branches and entire REs that contain quantified atoms. What that means is
          that the matching is done in such a way that the branch, or whole RE, matches the longest
          or shortest possible substring <i>as a whole</i>. Once the length of the entire match is
          determined, the part of it that matches any particular subexpression is determined on the
          basis of the greediness attribute of that subexpression, with subexpressions starting
          earlier in the RE taking priority over ones starting later. </p>
        <p> An example of what this means:
          <screen>
SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');
<b>Result: </b><codeph>123</codeph>
SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');
<b>Result: </b><codeph>1</codeph>
</screen>
          In the first case, the RE as a whole is greedy because <codeph>Y*</codeph> is greedy. It
          can match beginning at the <codeph>Y</codeph>, and it matches the longest possible string
          starting there, i.e., <codeph>Y123</codeph>. The output is the parenthesized part of that,
          or <codeph>123</codeph>. In the second case, the RE as a whole is non-greedy because
            <codeph>Y*?</codeph> is non-greedy. It can match beginning at the <codeph>Y</codeph>,
          and it matches the shortest possible string starting there, i.e., <codeph>Y1</codeph>. The
          subexpression <codeph>[0-9]{1,3}</codeph> is greedy but it cannot change the decision as
          to the overall match length; so it is forced to match just <codeph>1</codeph>. </p>
        <p> In short, when an RE contains both greedy and non-greedy subexpressions, the total match
          length is either as long as possible or as short as possible, according to the attribute
          assigned to the whole RE. The attributes assigned to the subexpressions only affect how
          much of that match they are allowed to "eat" relative to each other. </p>
        <p> The quantifiers <codeph>{1,1}</codeph> and <codeph>{1,1}?</codeph> can be used to force
          greediness or non-greediness, respectively, on a subexpression or a whole RE. </p>
        <p> Match lengths are measured in characters, not collating elements. An empty string is
          considered longer than no match at all. For example: <codeph>bb*</codeph> matches the
          three middle characters of <codeph>abbbc</codeph>;
            <codeph>(week|wee)(night|knights)</codeph> matches all ten characters of
            <codeph>weeknights</codeph>; when <codeph>(.*).*</codeph> is matched against
            <codeph>abc</codeph> the parenthesized subexpression matches all three characters; and
          when <codeph>(a*)*</codeph> is matched against <codeph>bc</codeph> both the whole RE and
          the parenthesized subexpression match an empty string. </p>
        <p> If case-independent matching is specified, the effect is much as if all case
          distinctions had vanished from the alphabet. When an alphabetic that exists in multiple
          cases appears as an ordinary character outside a bracket expression, it is effectively
          transformed into a bracket expression containing both cases, e.g. <codeph>x</codeph>
          becomes <codeph>[xX]</codeph>. When it appears inside a bracket expression, all case
          counterparts of it are added to the bracket expression, e.g. <codeph>[x]</codeph> becomes
            <codeph>[xX]</codeph> and <codeph>[^x]</codeph> becomes <codeph>[^xX]</codeph>. </p>
        <p> If newline-sensitive matching is specified, <codeph>.</codeph> and bracket expressions
          using <codeph>^</codeph> will never match the newline character (so that matches will
          never cross newlines unless the RE explicitly arranges it) and <codeph>^</codeph>and
            <codeph>$</codeph> will match the empty string after and before a newline respectively,
          in addition to matching at beginning and end of string respectively. But the ARE escapes
            <codeph>\A</codeph> and <codeph>\Z</codeph> continue to match beginning or end of string
            <i>only</i>. </p>
        <p> If partial newline-sensitive matching is specified, this affects <codeph>.</codeph> and
          bracket expressions as with newline-sensitive matching, but not <codeph>^</codeph> and
            <codeph>$</codeph>. </p>
        <p> If inverse partial newline-sensitive matching is specified, this affects
            <codeph>^</codeph> and <codeph>$</codeph> as with newline-sensitive matching, but not
            <codeph>.</codeph> and bracket expressions. This isn't very useful but is provided for
          symmetry. </p>
      </body>
    </topic>
    <topic id="posix-limits-compatibility">
      <title>Limits and Compatibility</title>
      <body>
        <p> No particular limit is imposed on the length of REs in this implementation. However,
          programs intended to be highly portable should not employ REs longer than 256 bytes, as a
          POSIX-compliant implementation can refuse to accept such REs. </p>
        <p> The only feature of AREs that is actually incompatible with POSIX EREs is that
            <codeph>\</codeph> does not lose its special significance inside bracket expressions.
          All other ARE features use syntax which is illegal or has undefined or unspecified effects
          in POSIX EREs; the <codeph>***</codeph> syntax of directors likewise is outside the POSIX
          syntax for both BREs and EREs. </p>
        <p> Many of the ARE extensions are borrowed from Perl, but some have been changed to clean
          them up, and a few Perl extensions are not present. Incompatibilities of note include
            <codeph>\b</codeph>, <codeph>\B</codeph>, the lack of special treatment for a trailing
          newline, the addition of complemented bracket expressions to the things affected by
          newline-sensitive matching, the restrictions on parentheses and back references in
          lookahead constraints, and the longest/shortest-match (rather than first-match) matching
          semantics. </p>
      </body>
    </topic>
    <topic id="posix-basic-regexes">
      <title>Basic Regular Expressions</title>
      <body>
        <p> BREs differ from EREs in several respects. <codeph>|</codeph>, <codeph>+</codeph>, and
            <codeph>?</codeph> are ordinary characters and there is no equivalent for their
          functionality. The delimiters for bounds are <codeph>\{</codeph> and <codeph>\}</codeph>,
          with <codeph>{</codeph> and <codeph>}</codeph> by themselves ordinary characters. The
          parentheses for nested subexpressions are <codeph>\(</codeph> and <codeph>\)</codeph>,
          with <codeph>(</codeph> and <codeph>)</codeph> by themselves ordinary characters.
            <codeph>^</codeph> is an ordinary character except at the beginning of the RE or the
          beginning of a parenthesized subexpression, <codeph>$</codeph> is an ordinary character
          except at the end of the RE or the end of a parenthesized subexpression, and
            <codeph>*</codeph> is an ordinary character if it appears at the beginning of the RE or
          the beginning of a parenthesized subexpression (after a possible leading
            <codeph>^</codeph>). Finally, single-digit back references are available, and
            <codeph>\&lt;</codeph> and <codeph>\&gt;</codeph> are synonyms for
            <codeph>[[:&lt;:]]</codeph> and <codeph>[[:&gt;:]]</codeph> respectively; no other
          escapes are available. </p>
      </body>
    </topic>
  </topic>
</topic>
